<html><head></head><body><div class="apidocDiv">
<style>
/*csslint
*/
.apidocDiv {
    background: #fff;
    font-family: Arial, Helvetica, sans-serif;
}
.apidocDiv a[href] {
    color: #33f;
    font-weight: bold;
    text-decoration: none;
}
.apidocDiv a[href]:hover {
    text-decoration: underline;
}
.apidocCodeCommentSpan {
    background: #bbf;
    color: #000;
    display: block;
}
.apidocCodeKeywordSpan {
    color: #d00;
    font-weight: bold;
}
.apidocCodePre {
    background: #eef;
    border: 1px solid;
    color: #777;
    padding: 5px;
    white-space: pre-wrap;
}
.apidocFooterDiv {
    margin-top: 20px;
    text-align: center;
}
.apidocModuleLi {
    margin-top: 10px;
}
.apidocSectionDiv {
    border-top: 1px solid;
    margin-top: 20px;
}
.apidocSignatureSpan {
    color: #777;
    font-weight: bold;
}
</style>
<h1>api documentation for
    <a href="https://github.com/MikeMcl/bignumber.js#readme">bignumber.js (v4.0.1)</a>
</h1>
<h4>A library for arbitrary-precision decimal and non-decimal arithmetic</h4>
<div class="apidocSectionDiv"><a href="#apidoc.tableOfContents" id="apidoc.tableOfContents"><h1>table of contents</h1></a><ol>

    <li class="apidocModuleLi"><a href="#apidoc.module.bignumber.js">module bignumber.js</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.bignumber.js.js">
            function <span class="apidocSignatureSpan">bignumber.</span>js
            <span class="apidocSignatureSpan">( n, b )</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.bignumber.js.BigNumber">
            function <span class="apidocSignatureSpan">bignumber.js.</span>BigNumber
            <span class="apidocSignatureSpan">( n, b )</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.bignumber.js.another">
            function <span class="apidocSignatureSpan">bignumber.js.</span>another
            <span class="apidocSignatureSpan">(config)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.bignumber.js.config">
            function <span class="apidocSignatureSpan">bignumber.js.</span>config
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.bignumber.js.default">
            function <span class="apidocSignatureSpan">bignumber.js.</span>default
            <span class="apidocSignatureSpan">( n, b )</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.bignumber.js.js.BigNumber">
            function <span class="apidocSignatureSpan">bignumber.js.</span>js.BigNumber
            <span class="apidocSignatureSpan">( n, b )</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.bignumber.js.max">
            function <span class="apidocSignatureSpan">bignumber.js.</span>max
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.bignumber.js.min">
            function <span class="apidocSignatureSpan">bignumber.js.</span>min
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.bignumber.js.random">
            function <span class="apidocSignatureSpan">bignumber.js.</span>random
            <span class="apidocSignatureSpan">(dp)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.bignumber.js.set">
            function <span class="apidocSignatureSpan">bignumber.js.</span>set
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">bignumber.js.</span>EUCLID</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">bignumber.js.</span>ROUND_CEIL</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">bignumber.js.</span>ROUND_DOWN</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">bignumber.js.</span>ROUND_FLOOR</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">bignumber.js.</span>ROUND_HALF_CEIL</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">bignumber.js.</span>ROUND_HALF_DOWN</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">bignumber.js.</span>ROUND_HALF_EVEN</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">bignumber.js.</span>ROUND_HALF_FLOOR</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">bignumber.js.</span>ROUND_HALF_UP</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">bignumber.js.</span>ROUND_UP</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">bignumber.js.</span>js.BigNumber.prototype</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.bignumber.js.BigNumber">module bignumber.js.BigNumber</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.bignumber.js.BigNumber.BigNumber">
            function <span class="apidocSignatureSpan">bignumber.js.</span>BigNumber
            <span class="apidocSignatureSpan">( n, b )</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.bignumber.js.BigNumber.another">
            function <span class="apidocSignatureSpan">bignumber.js.BigNumber.</span>another
            <span class="apidocSignatureSpan">(config)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.bignumber.js.BigNumber.config">
            function <span class="apidocSignatureSpan">bignumber.js.BigNumber.</span>config
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.bignumber.js.BigNumber.default">
            function <span class="apidocSignatureSpan">bignumber.js.BigNumber.</span>default
            <span class="apidocSignatureSpan">( n, b )</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.bignumber.js.BigNumber.max">
            function <span class="apidocSignatureSpan">bignumber.js.BigNumber.</span>max
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.bignumber.js.BigNumber.min">
            function <span class="apidocSignatureSpan">bignumber.js.BigNumber.</span>min
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.bignumber.js.BigNumber.random">
            function <span class="apidocSignatureSpan">bignumber.js.BigNumber.</span>random
            <span class="apidocSignatureSpan">(dp)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.bignumber.js.BigNumber.set">
            function <span class="apidocSignatureSpan">bignumber.js.BigNumber.</span>set
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">bignumber.js.BigNumber.</span>EUCLID</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">bignumber.js.BigNumber.</span>ROUND_CEIL</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">bignumber.js.BigNumber.</span>ROUND_DOWN</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">bignumber.js.BigNumber.</span>ROUND_FLOOR</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">bignumber.js.BigNumber.</span>ROUND_HALF_CEIL</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">bignumber.js.BigNumber.</span>ROUND_HALF_DOWN</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">bignumber.js.BigNumber.</span>ROUND_HALF_EVEN</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">bignumber.js.BigNumber.</span>ROUND_HALF_FLOOR</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">bignumber.js.BigNumber.</span>ROUND_HALF_UP</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">bignumber.js.BigNumber.</span>ROUND_UP</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.bignumber.js.BigNumber.prototype">module bignumber.js.BigNumber.prototype</a><ol>

        <li>

            <span class="apidocSignatureSpan">boolean <span class="apidocSignatureSpan">bignumber.js.BigNumber.prototype.</span>isBigNumber</span>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.bignumber.js.BigNumber.prototype.abs">
            function <span class="apidocSignatureSpan">bignumber.js.BigNumber.prototype.</span>abs
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.bignumber.js.BigNumber.prototype.absoluteValue">
            function <span class="apidocSignatureSpan">bignumber.js.BigNumber.prototype.</span>absoluteValue
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.bignumber.js.BigNumber.prototype.add">
            function <span class="apidocSignatureSpan">bignumber.js.BigNumber.prototype.</span>add
            <span class="apidocSignatureSpan">( y, b )</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.bignumber.js.BigNumber.prototype.ceil">
            function <span class="apidocSignatureSpan">bignumber.js.BigNumber.prototype.</span>ceil
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.bignumber.js.BigNumber.prototype.cmp">
            function <span class="apidocSignatureSpan">bignumber.js.BigNumber.prototype.</span>cmp
            <span class="apidocSignatureSpan">( y, b )</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.bignumber.js.BigNumber.prototype.comparedTo">
            function <span class="apidocSignatureSpan">bignumber.js.BigNumber.prototype.</span>comparedTo
            <span class="apidocSignatureSpan">( y, b )</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.bignumber.js.BigNumber.prototype.decimalPlaces">
            function <span class="apidocSignatureSpan">bignumber.js.BigNumber.prototype.</span>decimalPlaces
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.bignumber.js.BigNumber.prototype.div">
            function <span class="apidocSignatureSpan">bignumber.js.BigNumber.prototype.</span>div
            <span class="apidocSignatureSpan">( y, b )</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.bignumber.js.BigNumber.prototype.divToInt">
            function <span class="apidocSignatureSpan">bignumber.js.BigNumber.prototype.</span>divToInt
            <span class="apidocSignatureSpan">( y, b )</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.bignumber.js.BigNumber.prototype.dividedBy">
            function <span class="apidocSignatureSpan">bignumber.js.BigNumber.prototype.</span>dividedBy
            <span class="apidocSignatureSpan">( y, b )</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.bignumber.js.BigNumber.prototype.dividedToIntegerBy">
            function <span class="apidocSignatureSpan">bignumber.js.BigNumber.prototype.</span>dividedToIntegerBy
            <span class="apidocSignatureSpan">( y, b )</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.bignumber.js.BigNumber.prototype.dp">
            function <span class="apidocSignatureSpan">bignumber.js.BigNumber.prototype.</span>dp
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.bignumber.js.BigNumber.prototype.eq">
            function <span class="apidocSignatureSpan">bignumber.js.BigNumber.prototype.</span>eq
            <span class="apidocSignatureSpan">( y, b )</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.bignumber.js.BigNumber.prototype.equals">
            function <span class="apidocSignatureSpan">bignumber.js.BigNumber.prototype.</span>equals
            <span class="apidocSignatureSpan">( y, b )</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.bignumber.js.BigNumber.prototype.floor">
            function <span class="apidocSignatureSpan">bignumber.js.BigNumber.prototype.</span>floor
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.bignumber.js.BigNumber.prototype.greaterThan">
            function <span class="apidocSignatureSpan">bignumber.js.BigNumber.prototype.</span>greaterThan
            <span class="apidocSignatureSpan">( y, b )</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.bignumber.js.BigNumber.prototype.greaterThanOrEqualTo">
            function <span class="apidocSignatureSpan">bignumber.js.BigNumber.prototype.</span>greaterThanOrEqualTo
            <span class="apidocSignatureSpan">( y, b )</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.bignumber.js.BigNumber.prototype.gt">
            function <span class="apidocSignatureSpan">bignumber.js.BigNumber.prototype.</span>gt
            <span class="apidocSignatureSpan">( y, b )</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.bignumber.js.BigNumber.prototype.gte">
            function <span class="apidocSignatureSpan">bignumber.js.BigNumber.prototype.</span>gte
            <span class="apidocSignatureSpan">( y, b )</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.bignumber.js.BigNumber.prototype.isFinite">
            function <span class="apidocSignatureSpan">bignumber.js.BigNumber.prototype.</span>isFinite
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.bignumber.js.BigNumber.prototype.isInt">
            function <span class="apidocSignatureSpan">bignumber.js.BigNumber.prototype.</span>isInt
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.bignumber.js.BigNumber.prototype.isInteger">
            function <span class="apidocSignatureSpan">bignumber.js.BigNumber.prototype.</span>isInteger
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.bignumber.js.BigNumber.prototype.isNaN">
            function <span class="apidocSignatureSpan">bignumber.js.BigNumber.prototype.</span>isNaN
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.bignumber.js.BigNumber.prototype.isNeg">
            function <span class="apidocSignatureSpan">bignumber.js.BigNumber.prototype.</span>isNeg
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.bignumber.js.BigNumber.prototype.isNegative">
            function <span class="apidocSignatureSpan">bignumber.js.BigNumber.prototype.</span>isNegative
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.bignumber.js.BigNumber.prototype.isZero">
            function <span class="apidocSignatureSpan">bignumber.js.BigNumber.prototype.</span>isZero
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.bignumber.js.BigNumber.prototype.lessThan">
            function <span class="apidocSignatureSpan">bignumber.js.BigNumber.prototype.</span>lessThan
            <span class="apidocSignatureSpan">( y, b )</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.bignumber.js.BigNumber.prototype.lessThanOrEqualTo">
            function <span class="apidocSignatureSpan">bignumber.js.BigNumber.prototype.</span>lessThanOrEqualTo
            <span class="apidocSignatureSpan">( y, b )</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.bignumber.js.BigNumber.prototype.lt">
            function <span class="apidocSignatureSpan">bignumber.js.BigNumber.prototype.</span>lt
            <span class="apidocSignatureSpan">( y, b )</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.bignumber.js.BigNumber.prototype.lte">
            function <span class="apidocSignatureSpan">bignumber.js.BigNumber.prototype.</span>lte
            <span class="apidocSignatureSpan">( y, b )</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.bignumber.js.BigNumber.prototype.minus">
            function <span class="apidocSignatureSpan">bignumber.js.BigNumber.prototype.</span>minus
            <span class="apidocSignatureSpan">( y, b )</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.bignumber.js.BigNumber.prototype.mod">
            function <span class="apidocSignatureSpan">bignumber.js.BigNumber.prototype.</span>mod
            <span class="apidocSignatureSpan">( y, b )</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.bignumber.js.BigNumber.prototype.modulo">
            function <span class="apidocSignatureSpan">bignumber.js.BigNumber.prototype.</span>modulo
            <span class="apidocSignatureSpan">( y, b )</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.bignumber.js.BigNumber.prototype.mul">
            function <span class="apidocSignatureSpan">bignumber.js.BigNumber.prototype.</span>mul
            <span class="apidocSignatureSpan">( y, b )</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.bignumber.js.BigNumber.prototype.neg">
            function <span class="apidocSignatureSpan">bignumber.js.BigNumber.prototype.</span>neg
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.bignumber.js.BigNumber.prototype.negated">
            function <span class="apidocSignatureSpan">bignumber.js.BigNumber.prototype.</span>negated
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.bignumber.js.BigNumber.prototype.plus">
            function <span class="apidocSignatureSpan">bignumber.js.BigNumber.prototype.</span>plus
            <span class="apidocSignatureSpan">( y, b )</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.bignumber.js.BigNumber.prototype.pow">
            function <span class="apidocSignatureSpan">bignumber.js.BigNumber.prototype.</span>pow
            <span class="apidocSignatureSpan">( n, m )</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.bignumber.js.BigNumber.prototype.precision">
            function <span class="apidocSignatureSpan">bignumber.js.BigNumber.prototype.</span>precision
            <span class="apidocSignatureSpan">(z)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.bignumber.js.BigNumber.prototype.round">
            function <span class="apidocSignatureSpan">bignumber.js.BigNumber.prototype.</span>round
            <span class="apidocSignatureSpan">( dp, rm )</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.bignumber.js.BigNumber.prototype.sd">
            function <span class="apidocSignatureSpan">bignumber.js.BigNumber.prototype.</span>sd
            <span class="apidocSignatureSpan">(z)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.bignumber.js.BigNumber.prototype.shift">
            function <span class="apidocSignatureSpan">bignumber.js.BigNumber.prototype.</span>shift
            <span class="apidocSignatureSpan">(k)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.bignumber.js.BigNumber.prototype.sqrt">
            function <span class="apidocSignatureSpan">bignumber.js.BigNumber.prototype.</span>sqrt
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.bignumber.js.BigNumber.prototype.squareRoot">
            function <span class="apidocSignatureSpan">bignumber.js.BigNumber.prototype.</span>squareRoot
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.bignumber.js.BigNumber.prototype.sub">
            function <span class="apidocSignatureSpan">bignumber.js.BigNumber.prototype.</span>sub
            <span class="apidocSignatureSpan">( y, b )</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.bignumber.js.BigNumber.prototype.times">
            function <span class="apidocSignatureSpan">bignumber.js.BigNumber.prototype.</span>times
            <span class="apidocSignatureSpan">( y, b )</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.bignumber.js.BigNumber.prototype.toDigits">
            function <span class="apidocSignatureSpan">bignumber.js.BigNumber.prototype.</span>toDigits
            <span class="apidocSignatureSpan">( sd, rm )</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.bignumber.js.BigNumber.prototype.toExponential">
            function <span class="apidocSignatureSpan">bignumber.js.BigNumber.prototype.</span>toExponential
            <span class="apidocSignatureSpan">( dp, rm )</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.bignumber.js.BigNumber.prototype.toFixed">
            function <span class="apidocSignatureSpan">bignumber.js.BigNumber.prototype.</span>toFixed
            <span class="apidocSignatureSpan">( dp, rm )</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.bignumber.js.BigNumber.prototype.toFormat">
            function <span class="apidocSignatureSpan">bignumber.js.BigNumber.prototype.</span>toFormat
            <span class="apidocSignatureSpan">( dp, rm )</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.bignumber.js.BigNumber.prototype.toFraction">
            function <span class="apidocSignatureSpan">bignumber.js.BigNumber.prototype.</span>toFraction
            <span class="apidocSignatureSpan">(md)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.bignumber.js.BigNumber.prototype.toJSON">
            function <span class="apidocSignatureSpan">bignumber.js.BigNumber.prototype.</span>toJSON
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.bignumber.js.BigNumber.prototype.toNumber">
            function <span class="apidocSignatureSpan">bignumber.js.BigNumber.prototype.</span>toNumber
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.bignumber.js.BigNumber.prototype.toPower">
            function <span class="apidocSignatureSpan">bignumber.js.BigNumber.prototype.</span>toPower
            <span class="apidocSignatureSpan">( n, m )</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.bignumber.js.BigNumber.prototype.toPrecision">
            function <span class="apidocSignatureSpan">bignumber.js.BigNumber.prototype.</span>toPrecision
            <span class="apidocSignatureSpan">( sd, rm )</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.bignumber.js.BigNumber.prototype.toString">
            function <span class="apidocSignatureSpan">bignumber.js.BigNumber.prototype.</span>toString
            <span class="apidocSignatureSpan">(b)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.bignumber.js.BigNumber.prototype.trunc">
            function <span class="apidocSignatureSpan">bignumber.js.BigNumber.prototype.</span>trunc
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.bignumber.js.BigNumber.prototype.truncated">
            function <span class="apidocSignatureSpan">bignumber.js.BigNumber.prototype.</span>truncated
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.bignumber.js.BigNumber.prototype.valueOf">
            function <span class="apidocSignatureSpan">bignumber.js.BigNumber.prototype.</span>valueOf
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

</ol></div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.bignumber.js" id="apidoc.module.bignumber.js">module bignumber.js</a></h1>


    <h2>
        <a href="#apidoc.element.bignumber.js.js" id="apidoc.element.bignumber.js.js">
        function <span class="apidocSignatureSpan">bignumber.</span>js
        <span class="apidocSignatureSpan">( n, b )</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function BigNumber( n, b ) {
    var c, e, i, num, len, str,
        x = this;

    // Enable constructor usage without new.
    if ( !( x instanceof BigNumber ) ) {

        // 'BigNumber() constructor call without new: {n}'
        if (ERRORS) raise( 26, 'constructor call without new', n );
        return new BigNumber( n, b );
    }

    // 'new BigNumber() base not an integer: {b}'
    // 'new BigNumber() base out of range: {b}'
    if ( b == null || !isValidInt( b, 2, 64, id, 'base' ) ) {

        // Duplicate.
        if ( n instanceof BigNumber ) {
            x.s = n.s;
            x.e = n.e;
            x.c = ( n = n.c ) ? n.slice() : n;
            id = 0;
            return;
        }

        if ( ( num = typeof n == 'number' ) &amp;&amp; n * 0 == 0 ) {
            x.s = 1 / n &lt; 0 ? ( n = -n, -1 ) : 1;

            // Fast path for integers.
            if ( n === ~~n ) {
                for ( e = 0, i = n; i &gt;= 10; i /= 10, e++ );
                x.e = e;
                x.c = [n];
                id = 0;
                return;
            }

            str = n + '';
        } else {
            if ( !isNumeric.test( str = n + '' ) ) return parseNumeric( x, str, num );
            x.s = str.charCodeAt(0) === 45 ? ( str = str.slice(1), -1 ) : 1;
        }
    } else {
        b = b | 0;
        str = n + '';

        // Ensure return value is rounded to DECIMAL_PLACES as with other bases.
        // Allow exponential notation to be used with base 10 argument.
        if ( b == 10 ) {
            x = new BigNumber( n instanceof BigNumber ? n : str );
            return round( x, DECIMAL_PLACES + x.e + 1, ROUNDING_MODE );
        }

        // Avoid potential interpretation of Infinity and NaN as base 44+ values.
        // Any number in exponential form will fail due to the [Ee][+-].
        if ( ( num = typeof n == 'number' ) &amp;&amp; n * 0 != 0 ||
          !( new RegExp( '^-?' + ( c = '[' + ALPHABET.slice( 0, b ) + ']+' ) +
            '(?:\\.' + c + ')?$',b &lt; 37 ? 'i' : '' ) ).test(str) ) {
            return parseNumeric( x, str, num, b );
        }

        if (num) {
            x.s = 1 / n &lt; 0 ? ( str = str.slice(1), -1 ) : 1;

            if ( ERRORS &amp;&amp; str.replace( /^0\.0*|\./, '' ).length &gt; 15 ) {

                // 'new BigNumber() number type has more than 15 significant digits: {n}'
                raise( id, tooManyDigits, n );
            }

            // Prevent later check for length on converted number.
            num = false;
        } else {
            x.s = str.charCodeAt(0) === 45 ? ( str = str.slice(1), -1 ) : 1;
        }

        str = convertBase( str, 10, b, x.s );
    }

    // Decimal point?
    if ( ( e = str.indexOf('.') ) &gt; -1 ) str = str.replace( '.', '' );

    // Exponential form?
    if ( ( i = str.search( /e/i ) ) &gt; 0 ) {

        // Determine exponent.
        if ( e &lt; 0 ) e = i;
        e += +str.slice( i + 1 );
        str = str.substring( 0, i );
    } else if ( e &lt; 0 ) {

        // Integer.
        e = str.length;
    }

    // Determine leading zeros.
    for ( i = 0; str.charCodeAt(i) === 48; i++ );

    // Determine trailing zeros.
    for ( len = str.length; str.charCodeAt(--len) === 48; );
    str = str.slice( i, len + 1 );

    if (str) {
        len = str.length;

        // Disallow numbers with over 15 significant digits if number type.
        // 'new BigNumber() number type has more than 15 significant digits: {n}'
        if ( num &amp;&amp; ERRORS &amp;&amp; len &gt; 15 &amp;&amp; ( n &gt; MAX_SAFE_INTEGER || n !== mathfloor(n) ) ) {
            raise( id, tooManyDigits, x.s * n );
        }

        e = e - i - 1;

         // Overflow?
        if ( e &gt; MAX_EXP ) {

            // Infinity.
            x.c = x.e = null;

        // Underflow?
        } else if ( e &lt; MIN_EXP ) {

            // Zero.
            x.c = [ x.e = 0 ];
        } else {
            x.e = e;
            x.c = [];

            // Transform base

            // e is the base 10 exponent. ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.bignumber.js.BigNumber" id="apidoc.element.bignumber.js.BigNumber">
        function <span class="apidocSignatureSpan">bignumber.js.</span>BigNumber
        <span class="apidocSignatureSpan">( n, b )</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function BigNumber( n, b ) {
    var c, e, i, num, len, str,
        x = this;

    // Enable constructor usage without new.
    if ( !( x instanceof BigNumber ) ) {

        // 'BigNumber() constructor call without new: {n}'
        if (ERRORS) raise( 26, 'constructor call without new', n );
        return new BigNumber( n, b );
    }

    // 'new BigNumber() base not an integer: {b}'
    // 'new BigNumber() base out of range: {b}'
    if ( b == null || !isValidInt( b, 2, 64, id, 'base' ) ) {

        // Duplicate.
        if ( n instanceof BigNumber ) {
            x.s = n.s;
            x.e = n.e;
            x.c = ( n = n.c ) ? n.slice() : n;
            id = 0;
            return;
        }

        if ( ( num = typeof n == 'number' ) &amp;&amp; n * 0 == 0 ) {
            x.s = 1 / n &lt; 0 ? ( n = -n, -1 ) : 1;

            // Fast path for integers.
            if ( n === ~~n ) {
                for ( e = 0, i = n; i &gt;= 10; i /= 10, e++ );
                x.e = e;
                x.c = [n];
                id = 0;
                return;
            }

            str = n + '';
        } else {
            if ( !isNumeric.test( str = n + '' ) ) return parseNumeric( x, str, num );
            x.s = str.charCodeAt(0) === 45 ? ( str = str.slice(1), -1 ) : 1;
        }
    } else {
        b = b | 0;
        str = n + '';

        // Ensure return value is rounded to DECIMAL_PLACES as with other bases.
        // Allow exponential notation to be used with base 10 argument.
        if ( b == 10 ) {
            x = new BigNumber( n instanceof BigNumber ? n : str );
            return round( x, DECIMAL_PLACES + x.e + 1, ROUNDING_MODE );
        }

        // Avoid potential interpretation of Infinity and NaN as base 44+ values.
        // Any number in exponential form will fail due to the [Ee][+-].
        if ( ( num = typeof n == 'number' ) &amp;&amp; n * 0 != 0 ||
          !( new RegExp( '^-?' + ( c = '[' + ALPHABET.slice( 0, b ) + ']+' ) +
            '(?:\\.' + c + ')?$',b &lt; 37 ? 'i' : '' ) ).test(str) ) {
            return parseNumeric( x, str, num, b );
        }

        if (num) {
            x.s = 1 / n &lt; 0 ? ( str = str.slice(1), -1 ) : 1;

            if ( ERRORS &amp;&amp; str.replace( /^0\.0*|\./, '' ).length &gt; 15 ) {

                // 'new BigNumber() number type has more than 15 significant digits: {n}'
                raise( id, tooManyDigits, n );
            }

            // Prevent later check for length on converted number.
            num = false;
        } else {
            x.s = str.charCodeAt(0) === 45 ? ( str = str.slice(1), -1 ) : 1;
        }

        str = convertBase( str, 10, b, x.s );
    }

    // Decimal point?
    if ( ( e = str.indexOf('.') ) &gt; -1 ) str = str.replace( '.', '' );

    // Exponential form?
    if ( ( i = str.search( /e/i ) ) &gt; 0 ) {

        // Determine exponent.
        if ( e &lt; 0 ) e = i;
        e += +str.slice( i + 1 );
        str = str.substring( 0, i );
    } else if ( e &lt; 0 ) {

        // Integer.
        e = str.length;
    }

    // Determine leading zeros.
    for ( i = 0; str.charCodeAt(i) === 48; i++ );

    // Determine trailing zeros.
    for ( len = str.length; str.charCodeAt(--len) === 48; );
    str = str.slice( i, len + 1 );

    if (str) {
        len = str.length;

        // Disallow numbers with over 15 significant digits if number type.
        // 'new BigNumber() number type has more than 15 significant digits: {n}'
        if ( num &amp;&amp; ERRORS &amp;&amp; len &gt; 15 &amp;&amp; ( n &gt; MAX_SAFE_INTEGER || n !== mathfloor(n) ) ) {
            raise( id, tooManyDigits, x.s * n );
        }

        e = e - i - 1;

         // Overflow?
        if ( e &gt; MAX_EXP ) {

            // Infinity.
            x.c = x.e = null;

        // Underflow?
        } else if ( e &lt; MIN_EXP ) {

            // Zero.
            x.c = [ x.e = 0 ];
        } else {
            x.e = e;
            x.c = [];

            // Transform base

            // e is the base 10 exponent. ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.bignumber.js.another" id="apidoc.element.bignumber.js.another">
        function <span class="apidocSignatureSpan">bignumber.js.</span>another
        <span class="apidocSignatureSpan">(config)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function constructorFactory(config) {
    var div, parseNumeric,

        // id tracks the caller function, so its name can be included in error messages.
        id = 0,
        P = BigNumber.prototype,
        ONE = new BigNumber(1),


        /********************************* EDITABLE DEFAULTS **********************************/


        /*
         * The default values below must be integers within the inclusive ranges stated.
         * The values can also be changed at run-time using BigNumber.config.
         */

        // The maximum number of decimal places for operations involving division.
        DECIMAL_PLACES = 20,                     // 0 to MAX

        /*
         * The rounding mode used when rounding to the above decimal places, and when using
         * toExponential, toFixed, toFormat and toPrecision, and round (default value).
         * UP         0 Away from zero.
         * DOWN       1 Towards zero.
         * CEIL       2 Towards +Infinity.
         * FLOOR      3 Towards -Infinity.
         * HALF_UP    4 Towards nearest neighbour. If equidistant, up.
         * HALF_DOWN  5 Towards nearest neighbour. If equidistant, down.
         * HALF_EVEN  6 Towards nearest neighbour. If equidistant, towards even neighbour.
         * HALF_CEIL  7 Towards nearest neighbour. If equidistant, towards +Infinity.
         * HALF_FLOOR 8 Towards nearest neighbour. If equidistant, towards -Infinity.
         */
        ROUNDING_MODE = 4,                       // 0 to 8

        // EXPONENTIAL_AT : [TO_EXP_NEG , TO_EXP_POS]

        // The exponent value at and beneath which toString returns exponential notation.
        // Number type: -7
        TO_EXP_NEG = -7,                         // 0 to -MAX

        // The exponent value at and above which toString returns exponential notation.
        // Number type: 21
        TO_EXP_POS = 21,                         // 0 to MAX

        // RANGE : [MIN_EXP, MAX_EXP]

        // The minimum exponent value, beneath which underflow to zero occurs.
        // Number type: -324  (5e-324)
        MIN_EXP = -1e7,                          // -1 to -MAX

        // The maximum exponent value, above which overflow to Infinity occurs.
        // Number type:  308  (1.7976931348623157e+308)
        // For MAX_EXP &gt; 1e7, e.g. new BigNumber('1e100000000').plus(1) may be slow.
        MAX_EXP = 1e7,                           // 1 to MAX

        // Whether BigNumber Errors are ever thrown.
        ERRORS = true,                           // true or false

        // Change to intValidatorNoErrors if ERRORS is false.
        isValidInt = intValidatorWithErrors,     // intValidatorWithErrors/intValidatorNoErrors

        // Whether to use cryptographically-secure random number generation, if available.
        CRYPTO = false,                          // true or false

        /*
         * The modulo mode used when calculating the modulus: a mod n.
         * The quotient (q = a / n) is calculated according to the corresponding rounding mode.
         * The remainder (r) is calculated as: r = a - n * q.
         *
         * UP        0 The remainder is positive if the dividend is negative, else is negative.
         * DOWN      1 The remainder has the same sign as the dividend.
         *             This modulo mode is commonly known as 'truncated division' and is
         *             equivalent to (a % n) in JavaScript.
         * FLOOR     3 The remainder has the same sign as the divisor (Python %).
         * HALF_EVEN 6 This modulo mode implements the IEEE 754 remainder function.
         * EUCLID    9 Euclidian division. q = sign(n) * floor(a / abs(n)).
         *             The remainder is always positive.
         *
         * The truncated division, floored division, Euclidian division and IEEE 754 remainder
         * modes are commonly used for the modulus operation.
         * Although the other rounding modes can also be used, they may not give useful results.
         */
        M ...</pre></li>
    <li>example usage<pre class="apidocCodePre">...
Multiple BigNumber constructors can be created, each with their own independent configuration which applies to all BigNumber'
;s created from it.

```javascript
// Set DECIMAL_PLACES for the original BigNumber constructor
BigNumber.config({ DECIMAL_PLACES: 10 })

// Create another BigNumber constructor, optionally passing in a configuration object
BN = BigNumber.<span class="apidocCodeKeywordSpan">another</span>({ DECIMAL_PLACES: 5 })

x = new BigNumber(1)
y = new BN(1)

x.div(3)                            // '0.3333333333'
y.div(3)                            // '0.33333'
```
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.bignumber.js.config" id="apidoc.element.bignumber.js.config">
        function <span class="apidocSignatureSpan">bignumber.js.</span>config
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">config = function () {
    var v, p,
        i = 0,
        r = {},
        a = arguments,
        o = a[0],
        has = o &amp;&amp; typeof o == 'object'
          ? function () { if ( o.hasOwnProperty(p) ) return ( v = o[p] ) != null; }
          : function () { if ( a.length &gt; i ) return ( v = a[i++] ) != null; };

    // DECIMAL_PLACES {number} Integer, 0 to MAX inclusive.
    // 'config() DECIMAL_PLACES not an integer: {v}'
    // 'config() DECIMAL_PLACES out of range: {v}'
    if ( has( p = 'DECIMAL_PLACES' ) &amp;&amp; isValidInt( v, 0, MAX, 2, p ) ) {
        DECIMAL_PLACES = v | 0;
    }
    r[p] = DECIMAL_PLACES;

    // ROUNDING_MODE {number} Integer, 0 to 8 inclusive.
    // 'config() ROUNDING_MODE not an integer: {v}'
    // 'config() ROUNDING_MODE out of range: {v}'
    if ( has( p = 'ROUNDING_MODE' ) &amp;&amp; isValidInt( v, 0, 8, 2, p ) ) {
        ROUNDING_MODE = v | 0;
    }
    r[p] = ROUNDING_MODE;

    // EXPONENTIAL_AT {number|number[]}
    // Integer, -MAX to MAX inclusive or [integer -MAX to 0 inclusive, 0 to MAX inclusive].
    // 'config() EXPONENTIAL_AT not an integer: {v}'
    // 'config() EXPONENTIAL_AT out of range: {v}'
    if ( has( p = 'EXPONENTIAL_AT' ) ) {

        if ( isArray(v) ) {
            if ( isValidInt( v[0], -MAX, 0, 2, p ) &amp;&amp; isValidInt( v[1], 0, MAX, 2, p ) ) {
                TO_EXP_NEG = v[0] | 0;
                TO_EXP_POS = v[1] | 0;
            }
        } else if ( isValidInt( v, -MAX, MAX, 2, p ) ) {
            TO_EXP_NEG = -( TO_EXP_POS = ( v &lt; 0 ? -v : v ) | 0 );
        }
    }
    r[p] = [ TO_EXP_NEG, TO_EXP_POS ];

    // RANGE {number|number[]} Non-zero integer, -MAX to MAX inclusive or
    // [integer -MAX to -1 inclusive, integer 1 to MAX inclusive].
    // 'config() RANGE not an integer: {v}'
    // 'config() RANGE cannot be zero: {v}'
    // 'config() RANGE out of range: {v}'
    if ( has( p = 'RANGE' ) ) {

        if ( isArray(v) ) {
            if ( isValidInt( v[0], -MAX, -1, 2, p ) &amp;&amp; isValidInt( v[1], 1, MAX, 2, p ) ) {
                MIN_EXP = v[0] | 0;
                MAX_EXP = v[1] | 0;
            }
        } else if ( isValidInt( v, -MAX, MAX, 2, p ) ) {
            if ( v | 0 ) MIN_EXP = -( MAX_EXP = ( v &lt; 0 ? -v : v ) | 0 );
            else if (ERRORS) raise( 2, p + ' cannot be zero', v );
        }
    }
    r[p] = [ MIN_EXP, MAX_EXP ];

    // ERRORS {boolean|number} true, false, 1 or 0.
    // 'config() ERRORS not a boolean or binary digit: {v}'
    if ( has( p = 'ERRORS' ) ) {

        if ( v === !!v || v === 1 || v === 0 ) {
            id = 0;
            isValidInt = ( ERRORS = !!v ) ? intValidatorWithErrors : intValidatorNoErrors;
        } else if (ERRORS) {
            raise( 2, p + notBool, v );
        }
    }
    r[p] = ERRORS;

    // CRYPTO {boolean|number} true, false, 1 or 0.
    // 'config() CRYPTO not a boolean or binary digit: {v}'
    // 'config() crypto unavailable: {crypto}'
    if ( has( p = 'CRYPTO' ) ) {

        if ( v === true || v === false || v === 1 || v === 0 ) {
            if (v) {
                v = typeof crypto == 'undefined';
                if ( !v &amp;&amp; crypto &amp;&amp; (crypto.getRandomValues || crypto.randomBytes)) {
                    CRYPTO = true;
                } else if (ERRORS) {
                    raise( 2, 'crypto unavailable', v ? void 0 : crypto );
                } else {
                    CRYPTO = false;
                }
            } else {
                CRYPTO = false;
            }
        } else if (ERRORS) {
            raise( 2, p + notBool, v );
        }
    }
    r[p] = CRYPTO;

    // MODULO_MODE {number} Integer, 0 to 9 inclusive.
    // 'config() MODULO_MODE not an integer: {v}'
    // 'config() MODULO_MODE out of range: {v}'
    if ( has( p = 'MODULO_MODE' ) &amp;&amp; isValidInt( v, 0, 9, 2, p ) ) {
        MODULO_MODE = v | 0;
    }
    r[p] = MODULO_MODE;

    // POW_PRECISION {number} Integer, 0 to MAX inclusive.
    // 'config() POW_PRECISION not an integer: {v}'
    // 'config() POW_PRECISION out of r ...</pre></li>
    <li>example usage<pre class="apidocCodePre">...
```

The maximum number of decimal places of the result of an operation involving division (i.e. a division, square root, base conversion
 or negative power operation) is set using the `config` method of the `BigNumber` constructor.

The other arithmetic operations always give the exact result.

```javascript
BigNumber.<span class="apidocCodeKeywordSpan">config</span>({ DECIMAL_PLACES: 10, ROUNDING_MODE: 4 })

x = new BigNumber(2);
y = new BigNumber(3);
z = x.div(y)                        // "0.6666666667"
z.sqrt()                            // "0.8164965809"
z.pow(-3)                           // "3.3749999995"
z.toString(2)                       // "0.1010101011"
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.bignumber.js.default" id="apidoc.element.bignumber.js.default">
        function <span class="apidocSignatureSpan">bignumber.js.</span>default
        <span class="apidocSignatureSpan">( n, b )</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function BigNumber( n, b ) {
    var c, e, i, num, len, str,
        x = this;

    // Enable constructor usage without new.
    if ( !( x instanceof BigNumber ) ) {

        // 'BigNumber() constructor call without new: {n}'
        if (ERRORS) raise( 26, 'constructor call without new', n );
        return new BigNumber( n, b );
    }

    // 'new BigNumber() base not an integer: {b}'
    // 'new BigNumber() base out of range: {b}'
    if ( b == null || !isValidInt( b, 2, 64, id, 'base' ) ) {

        // Duplicate.
        if ( n instanceof BigNumber ) {
            x.s = n.s;
            x.e = n.e;
            x.c = ( n = n.c ) ? n.slice() : n;
            id = 0;
            return;
        }

        if ( ( num = typeof n == 'number' ) &amp;&amp; n * 0 == 0 ) {
            x.s = 1 / n &lt; 0 ? ( n = -n, -1 ) : 1;

            // Fast path for integers.
            if ( n === ~~n ) {
                for ( e = 0, i = n; i &gt;= 10; i /= 10, e++ );
                x.e = e;
                x.c = [n];
                id = 0;
                return;
            }

            str = n + '';
        } else {
            if ( !isNumeric.test( str = n + '' ) ) return parseNumeric( x, str, num );
            x.s = str.charCodeAt(0) === 45 ? ( str = str.slice(1), -1 ) : 1;
        }
    } else {
        b = b | 0;
        str = n + '';

        // Ensure return value is rounded to DECIMAL_PLACES as with other bases.
        // Allow exponential notation to be used with base 10 argument.
        if ( b == 10 ) {
            x = new BigNumber( n instanceof BigNumber ? n : str );
            return round( x, DECIMAL_PLACES + x.e + 1, ROUNDING_MODE );
        }

        // Avoid potential interpretation of Infinity and NaN as base 44+ values.
        // Any number in exponential form will fail due to the [Ee][+-].
        if ( ( num = typeof n == 'number' ) &amp;&amp; n * 0 != 0 ||
          !( new RegExp( '^-?' + ( c = '[' + ALPHABET.slice( 0, b ) + ']+' ) +
            '(?:\\.' + c + ')?$',b &lt; 37 ? 'i' : '' ) ).test(str) ) {
            return parseNumeric( x, str, num, b );
        }

        if (num) {
            x.s = 1 / n &lt; 0 ? ( str = str.slice(1), -1 ) : 1;

            if ( ERRORS &amp;&amp; str.replace( /^0\.0*|\./, '' ).length &gt; 15 ) {

                // 'new BigNumber() number type has more than 15 significant digits: {n}'
                raise( id, tooManyDigits, n );
            }

            // Prevent later check for length on converted number.
            num = false;
        } else {
            x.s = str.charCodeAt(0) === 45 ? ( str = str.slice(1), -1 ) : 1;
        }

        str = convertBase( str, 10, b, x.s );
    }

    // Decimal point?
    if ( ( e = str.indexOf('.') ) &gt; -1 ) str = str.replace( '.', '' );

    // Exponential form?
    if ( ( i = str.search( /e/i ) ) &gt; 0 ) {

        // Determine exponent.
        if ( e &lt; 0 ) e = i;
        e += +str.slice( i + 1 );
        str = str.substring( 0, i );
    } else if ( e &lt; 0 ) {

        // Integer.
        e = str.length;
    }

    // Determine leading zeros.
    for ( i = 0; str.charCodeAt(i) === 48; i++ );

    // Determine trailing zeros.
    for ( len = str.length; str.charCodeAt(--len) === 48; );
    str = str.slice( i, len + 1 );

    if (str) {
        len = str.length;

        // Disallow numbers with over 15 significant digits if number type.
        // 'new BigNumber() number type has more than 15 significant digits: {n}'
        if ( num &amp;&amp; ERRORS &amp;&amp; len &gt; 15 &amp;&amp; ( n &gt; MAX_SAFE_INTEGER || n !== mathfloor(n) ) ) {
            raise( id, tooManyDigits, x.s * n );
        }

        e = e - i - 1;

         // Overflow?
        if ( e &gt; MAX_EXP ) {

            // Infinity.
            x.c = x.e = null;

        // Underflow?
        } else if ( e &lt; MIN_EXP ) {

            // Zero.
            x.c = [ x.e = 0 ];
        } else {
            x.e = e;
            x.c = [];

            // Transform base

            // e is the base 10 exponent. ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.bignumber.js.js.BigNumber" id="apidoc.element.bignumber.js.js.BigNumber">
        function <span class="apidocSignatureSpan">bignumber.js.</span>js.BigNumber
        <span class="apidocSignatureSpan">( n, b )</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function BigNumber( n, b ) {
    var c, e, i, num, len, str,
        x = this;

    // Enable constructor usage without new.
    if ( !( x instanceof BigNumber ) ) {

        // 'BigNumber() constructor call without new: {n}'
        if (ERRORS) raise( 26, 'constructor call without new', n );
        return new BigNumber( n, b );
    }

    // 'new BigNumber() base not an integer: {b}'
    // 'new BigNumber() base out of range: {b}'
    if ( b == null || !isValidInt( b, 2, 64, id, 'base' ) ) {

        // Duplicate.
        if ( n instanceof BigNumber ) {
            x.s = n.s;
            x.e = n.e;
            x.c = ( n = n.c ) ? n.slice() : n;
            id = 0;
            return;
        }

        if ( ( num = typeof n == 'number' ) &amp;&amp; n * 0 == 0 ) {
            x.s = 1 / n &lt; 0 ? ( n = -n, -1 ) : 1;

            // Fast path for integers.
            if ( n === ~~n ) {
                for ( e = 0, i = n; i &gt;= 10; i /= 10, e++ );
                x.e = e;
                x.c = [n];
                id = 0;
                return;
            }

            str = n + '';
        } else {
            if ( !isNumeric.test( str = n + '' ) ) return parseNumeric( x, str, num );
            x.s = str.charCodeAt(0) === 45 ? ( str = str.slice(1), -1 ) : 1;
        }
    } else {
        b = b | 0;
        str = n + '';

        // Ensure return value is rounded to DECIMAL_PLACES as with other bases.
        // Allow exponential notation to be used with base 10 argument.
        if ( b == 10 ) {
            x = new BigNumber( n instanceof BigNumber ? n : str );
            return round( x, DECIMAL_PLACES + x.e + 1, ROUNDING_MODE );
        }

        // Avoid potential interpretation of Infinity and NaN as base 44+ values.
        // Any number in exponential form will fail due to the [Ee][+-].
        if ( ( num = typeof n == 'number' ) &amp;&amp; n * 0 != 0 ||
          !( new RegExp( '^-?' + ( c = '[' + ALPHABET.slice( 0, b ) + ']+' ) +
            '(?:\\.' + c + ')?$',b &lt; 37 ? 'i' : '' ) ).test(str) ) {
            return parseNumeric( x, str, num, b );
        }

        if (num) {
            x.s = 1 / n &lt; 0 ? ( str = str.slice(1), -1 ) : 1;

            if ( ERRORS &amp;&amp; str.replace( /^0\.0*|\./, '' ).length &gt; 15 ) {

                // 'new BigNumber() number type has more than 15 significant digits: {n}'
                raise( id, tooManyDigits, n );
            }

            // Prevent later check for length on converted number.
            num = false;
        } else {
            x.s = str.charCodeAt(0) === 45 ? ( str = str.slice(1), -1 ) : 1;
        }

        str = convertBase( str, 10, b, x.s );
    }

    // Decimal point?
    if ( ( e = str.indexOf('.') ) &gt; -1 ) str = str.replace( '.', '' );

    // Exponential form?
    if ( ( i = str.search( /e/i ) ) &gt; 0 ) {

        // Determine exponent.
        if ( e &lt; 0 ) e = i;
        e += +str.slice( i + 1 );
        str = str.substring( 0, i );
    } else if ( e &lt; 0 ) {

        // Integer.
        e = str.length;
    }

    // Determine leading zeros.
    for ( i = 0; str.charCodeAt(i) === 48; i++ );

    // Determine trailing zeros.
    for ( len = str.length; str.charCodeAt(--len) === 48; );
    str = str.slice( i, len + 1 );

    if (str) {
        len = str.length;

        // Disallow numbers with over 15 significant digits if number type.
        // 'new BigNumber() number type has more than 15 significant digits: {n}'
        if ( num &amp;&amp; ERRORS &amp;&amp; len &gt; 15 &amp;&amp; ( n &gt; MAX_SAFE_INTEGER || n !== mathfloor(n) ) ) {
            raise( id, tooManyDigits, x.s * n );
        }

        e = e - i - 1;

         // Overflow?
        if ( e &gt; MAX_EXP ) {

            // Infinity.
            x.c = x.e = null;

        // Underflow?
        } else if ( e &lt; MIN_EXP ) {

            // Zero.
            x.c = [ x.e = 0 ];
        } else {
            x.e = e;
            x.c = [];

            // Transform base

            // e is the base 10 exponent. ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.bignumber.js.max" id="apidoc.element.bignumber.js.max">
        function <span class="apidocSignatureSpan">bignumber.js.</span>max
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">max = function () { return maxOrMin( arguments, P.lt ); }</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.bignumber.js.min" id="apidoc.element.bignumber.js.min">
        function <span class="apidocSignatureSpan">bignumber.js.</span>min
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">min = function () { return maxOrMin( arguments, P.gt ); }</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.bignumber.js.random" id="apidoc.element.bignumber.js.random">
        function <span class="apidocSignatureSpan">bignumber.js.</span>random
        <span class="apidocSignatureSpan">(dp)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">random = function (dp) {
    var a, b, e, k, v,
        i = 0,
        c = [],
        rand = new BigNumber(ONE);

    dp = dp == null || !isValidInt( dp, 0, MAX, 14 ) ? DECIMAL_PLACES : dp | 0;
    k = mathceil( dp / LOG_BASE );

    if (CRYPTO) {

        // Browsers supporting crypto.getRandomValues.
        if (crypto.getRandomValues) {

            a = crypto.getRandomValues( new Uint32Array( k *= 2 ) );

            for ( ; i &lt; k; ) {

                // 53 bits:
                // ((Math.pow(2, 32) - 1) * Math.pow(2, 21)).toString(2)
                // 11111 11111111 11111111 11111111 11100000 00000000 00000000
                // ((Math.pow(2, 32) - 1) &gt;&gt;&gt; 11).toString(2)
                //                                     11111 11111111 11111111
                // 0x20000 is 2^21.
                v = a[i] * 0x20000 + (a[i + 1] &gt;&gt;&gt; 11);

                // Rejection sampling:
                // 0 &lt;= v &lt; 9007199254740992
                // Probability that v &gt;= 9e15, is
                // 7199254740992 / 9007199254740992 ~= 0.0008, i.e. 1 in 1251
                if ( v &gt;= 9e15 ) {
                    b = crypto.getRandomValues( new Uint32Array(2) );
                    a[i] = b[0];
                    a[i + 1] = b[1];
                } else {

                    // 0 &lt;= v &lt;= 8999999999999999
                    // 0 &lt;= (v % 1e14) &lt;= 99999999999999
                    c.push( v % 1e14 );
                    i += 2;
                }
            }
            i = k / 2;

        // Node.js supporting crypto.randomBytes.
        } else if (crypto.randomBytes) {

            // buffer
            a = crypto.randomBytes( k *= 7 );

            for ( ; i &lt; k; ) {

                // 0x1000000000000 is 2^48, 0x10000000000 is 2^40
                // 0x100000000 is 2^32, 0x1000000 is 2^24
                // 11111 11111111 11111111 11111111 11111111 11111111 11111111
                // 0 &lt;= v &lt; 9007199254740992
                v = ( ( a[i] &amp; 31 ) * 0x1000000000000 ) + ( a[i + 1] * 0x10000000000 ) +
                      ( a[i + 2] * 0x100000000 ) + ( a[i + 3] * 0x1000000 ) +
                      ( a[i + 4] &lt;&lt; 16 ) + ( a[i + 5] &lt;&lt; 8 ) + a[i + 6];

                if ( v &gt;= 9e15 ) {
                    crypto.randomBytes(7).copy( a, i );
                } else {

                    // 0 &lt;= (v % 1e14) &lt;= 99999999999999
                    c.push( v % 1e14 );
                    i += 7;
                }
            }
            i = k / 7;
        } else {
            CRYPTO = false;
            if (ERRORS) raise( 14, 'crypto unavailable', crypto );
        }
    }

    // Use Math.random.
    if (!CRYPTO) {

        for ( ; i &lt; k; ) {
            v = random53bitInt();
            if ( v &lt; 9e15 ) c[i++] = v % 1e14;
        }
    }

    k = c[--i];
    dp %= LOG_BASE;

    // Convert trailing digits to zeros according to dp.
    if ( k &amp;&amp; dp ) {
        v = POWS_TEN[LOG_BASE - dp];
        c[i] = mathfloor( k / v ) * v;
    }

    // Remove trailing elements which are zero.
    for ( ; c[i] === 0; c.pop(), i-- );

    // Zero?
    if ( i &lt; 0 ) {
        c = [ e = 0 ];
    } else {

        // Remove leading elements which are zero and adjust exponent accordingly.
        for ( e = -1 ; c[0] === 0; c.shift(), e -= LOG_BASE);

        // Count the digits of the first element of c to determine leading zeros, and...
        for ( i = 1, v = c[0]; v &gt;= 10; v /= 10, i++);

        // adjust the exponent accordingly.
        if ( i &lt; LOG_BASE ) e -= LOG_BASE - i;
    }

    rand.e = e;
    rand.c = c;
    return rand;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
         * 'random() decimal places out of range: {dp}'
         * 'random() crypto unavailable: {crypto}'
         */
        BigNumber.random = (function () {
var pow2_53 = 0x20000000000000;

// Return a 53 bit integer n, where 0 &lt;= n &lt; 9007199254740992.
// Check if Math.<span class="apidocCodeKeywordSpan">random</span>() produces more than 32 bits of randomness.
// If it does, assume at least 53 bits are produced, otherwise assume at least 30 bits.
// 0x40000000 is 2^30, 0x800000 is 2^23, 0x1fffff is 2^21 - 1.
var random53bitInt = (Math.random() * pow2_53) &amp; 0x1fffff
  ? function () { return mathfloor( Math.random() * pow2_53 ); }
  : function () { return ((Math.random() * 0x40000000 | 0) * 0x800000) +
      (Math.random() * 0x800000 | 0); };
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.bignumber.js.set" id="apidoc.element.bignumber.js.set">
        function <span class="apidocSignatureSpan">bignumber.js.</span>set
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">set = function () {
    var v, p,
        i = 0,
        r = {},
        a = arguments,
        o = a[0],
        has = o &amp;&amp; typeof o == 'object'
          ? function () { if ( o.hasOwnProperty(p) ) return ( v = o[p] ) != null; }
          : function () { if ( a.length &gt; i ) return ( v = a[i++] ) != null; };

    // DECIMAL_PLACES {number} Integer, 0 to MAX inclusive.
    // 'config() DECIMAL_PLACES not an integer: {v}'
    // 'config() DECIMAL_PLACES out of range: {v}'
    if ( has( p = 'DECIMAL_PLACES' ) &amp;&amp; isValidInt( v, 0, MAX, 2, p ) ) {
        DECIMAL_PLACES = v | 0;
    }
    r[p] = DECIMAL_PLACES;

    // ROUNDING_MODE {number} Integer, 0 to 8 inclusive.
    // 'config() ROUNDING_MODE not an integer: {v}'
    // 'config() ROUNDING_MODE out of range: {v}'
    if ( has( p = 'ROUNDING_MODE' ) &amp;&amp; isValidInt( v, 0, 8, 2, p ) ) {
        ROUNDING_MODE = v | 0;
    }
    r[p] = ROUNDING_MODE;

    // EXPONENTIAL_AT {number|number[]}
    // Integer, -MAX to MAX inclusive or [integer -MAX to 0 inclusive, 0 to MAX inclusive].
    // 'config() EXPONENTIAL_AT not an integer: {v}'
    // 'config() EXPONENTIAL_AT out of range: {v}'
    if ( has( p = 'EXPONENTIAL_AT' ) ) {

        if ( isArray(v) ) {
            if ( isValidInt( v[0], -MAX, 0, 2, p ) &amp;&amp; isValidInt( v[1], 0, MAX, 2, p ) ) {
                TO_EXP_NEG = v[0] | 0;
                TO_EXP_POS = v[1] | 0;
            }
        } else if ( isValidInt( v, -MAX, MAX, 2, p ) ) {
            TO_EXP_NEG = -( TO_EXP_POS = ( v &lt; 0 ? -v : v ) | 0 );
        }
    }
    r[p] = [ TO_EXP_NEG, TO_EXP_POS ];

    // RANGE {number|number[]} Non-zero integer, -MAX to MAX inclusive or
    // [integer -MAX to -1 inclusive, integer 1 to MAX inclusive].
    // 'config() RANGE not an integer: {v}'
    // 'config() RANGE cannot be zero: {v}'
    // 'config() RANGE out of range: {v}'
    if ( has( p = 'RANGE' ) ) {

        if ( isArray(v) ) {
            if ( isValidInt( v[0], -MAX, -1, 2, p ) &amp;&amp; isValidInt( v[1], 1, MAX, 2, p ) ) {
                MIN_EXP = v[0] | 0;
                MAX_EXP = v[1] | 0;
            }
        } else if ( isValidInt( v, -MAX, MAX, 2, p ) ) {
            if ( v | 0 ) MIN_EXP = -( MAX_EXP = ( v &lt; 0 ? -v : v ) | 0 );
            else if (ERRORS) raise( 2, p + ' cannot be zero', v );
        }
    }
    r[p] = [ MIN_EXP, MAX_EXP ];

    // ERRORS {boolean|number} true, false, 1 or 0.
    // 'config() ERRORS not a boolean or binary digit: {v}'
    if ( has( p = 'ERRORS' ) ) {

        if ( v === !!v || v === 1 || v === 0 ) {
            id = 0;
            isValidInt = ( ERRORS = !!v ) ? intValidatorWithErrors : intValidatorNoErrors;
        } else if (ERRORS) {
            raise( 2, p + notBool, v );
        }
    }
    r[p] = ERRORS;

    // CRYPTO {boolean|number} true, false, 1 or 0.
    // 'config() CRYPTO not a boolean or binary digit: {v}'
    // 'config() crypto unavailable: {crypto}'
    if ( has( p = 'CRYPTO' ) ) {

        if ( v === true || v === false || v === 1 || v === 0 ) {
            if (v) {
                v = typeof crypto == 'undefined';
                if ( !v &amp;&amp; crypto &amp;&amp; (crypto.getRandomValues || crypto.randomBytes)) {
                    CRYPTO = true;
                } else if (ERRORS) {
                    raise( 2, 'crypto unavailable', v ? void 0 : crypto );
                } else {
                    CRYPTO = false;
                }
            } else {
                CRYPTO = false;
            }
        } else if (ERRORS) {
            raise( 2, p + notBool, v );
        }
    }
    r[p] = CRYPTO;

    // MODULO_MODE {number} Integer, 0 to 9 inclusive.
    // 'config() MODULO_MODE not an integer: {v}'
    // 'config() MODULO_MODE out of range: {v}'
    if ( has( p = 'MODULO_MODE' ) &amp;&amp; isValidInt( v, 0, 9, 2, p ) ) {
        MODULO_MODE = v | 0;
    }
    r[p] = MODULO_MODE;

    // POW_PRECISION {number} Integer, 0 to MAX inclusive.
    // 'config() POW_PRECISION not an integer: {v}'
    // 'config() POW_PRECISION out of r ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>
























</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.bignumber.js.BigNumber" id="apidoc.module.bignumber.js.BigNumber">module bignumber.js.BigNumber</a></h1>


    <h2>
        <a href="#apidoc.element.bignumber.js.BigNumber.BigNumber" id="apidoc.element.bignumber.js.BigNumber.BigNumber">
        function <span class="apidocSignatureSpan">bignumber.js.</span>BigNumber
        <span class="apidocSignatureSpan">( n, b )</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function BigNumber( n, b ) {
    var c, e, i, num, len, str,
        x = this;

    // Enable constructor usage without new.
    if ( !( x instanceof BigNumber ) ) {

        // 'BigNumber() constructor call without new: {n}'
        if (ERRORS) raise( 26, 'constructor call without new', n );
        return new BigNumber( n, b );
    }

    // 'new BigNumber() base not an integer: {b}'
    // 'new BigNumber() base out of range: {b}'
    if ( b == null || !isValidInt( b, 2, 64, id, 'base' ) ) {

        // Duplicate.
        if ( n instanceof BigNumber ) {
            x.s = n.s;
            x.e = n.e;
            x.c = ( n = n.c ) ? n.slice() : n;
            id = 0;
            return;
        }

        if ( ( num = typeof n == 'number' ) &amp;&amp; n * 0 == 0 ) {
            x.s = 1 / n &lt; 0 ? ( n = -n, -1 ) : 1;

            // Fast path for integers.
            if ( n === ~~n ) {
                for ( e = 0, i = n; i &gt;= 10; i /= 10, e++ );
                x.e = e;
                x.c = [n];
                id = 0;
                return;
            }

            str = n + '';
        } else {
            if ( !isNumeric.test( str = n + '' ) ) return parseNumeric( x, str, num );
            x.s = str.charCodeAt(0) === 45 ? ( str = str.slice(1), -1 ) : 1;
        }
    } else {
        b = b | 0;
        str = n + '';

        // Ensure return value is rounded to DECIMAL_PLACES as with other bases.
        // Allow exponential notation to be used with base 10 argument.
        if ( b == 10 ) {
            x = new BigNumber( n instanceof BigNumber ? n : str );
            return round( x, DECIMAL_PLACES + x.e + 1, ROUNDING_MODE );
        }

        // Avoid potential interpretation of Infinity and NaN as base 44+ values.
        // Any number in exponential form will fail due to the [Ee][+-].
        if ( ( num = typeof n == 'number' ) &amp;&amp; n * 0 != 0 ||
          !( new RegExp( '^-?' + ( c = '[' + ALPHABET.slice( 0, b ) + ']+' ) +
            '(?:\\.' + c + ')?$',b &lt; 37 ? 'i' : '' ) ).test(str) ) {
            return parseNumeric( x, str, num, b );
        }

        if (num) {
            x.s = 1 / n &lt; 0 ? ( str = str.slice(1), -1 ) : 1;

            if ( ERRORS &amp;&amp; str.replace( /^0\.0*|\./, '' ).length &gt; 15 ) {

                // 'new BigNumber() number type has more than 15 significant digits: {n}'
                raise( id, tooManyDigits, n );
            }

            // Prevent later check for length on converted number.
            num = false;
        } else {
            x.s = str.charCodeAt(0) === 45 ? ( str = str.slice(1), -1 ) : 1;
        }

        str = convertBase( str, 10, b, x.s );
    }

    // Decimal point?
    if ( ( e = str.indexOf('.') ) &gt; -1 ) str = str.replace( '.', '' );

    // Exponential form?
    if ( ( i = str.search( /e/i ) ) &gt; 0 ) {

        // Determine exponent.
        if ( e &lt; 0 ) e = i;
        e += +str.slice( i + 1 );
        str = str.substring( 0, i );
    } else if ( e &lt; 0 ) {

        // Integer.
        e = str.length;
    }

    // Determine leading zeros.
    for ( i = 0; str.charCodeAt(i) === 48; i++ );

    // Determine trailing zeros.
    for ( len = str.length; str.charCodeAt(--len) === 48; );
    str = str.slice( i, len + 1 );

    if (str) {
        len = str.length;

        // Disallow numbers with over 15 significant digits if number type.
        // 'new BigNumber() number type has more than 15 significant digits: {n}'
        if ( num &amp;&amp; ERRORS &amp;&amp; len &gt; 15 &amp;&amp; ( n &gt; MAX_SAFE_INTEGER || n !== mathfloor(n) ) ) {
            raise( id, tooManyDigits, x.s * n );
        }

        e = e - i - 1;

         // Overflow?
        if ( e &gt; MAX_EXP ) {

            // Infinity.
            x.c = x.e = null;

        // Underflow?
        } else if ( e &lt; MIN_EXP ) {

            // Zero.
            x.c = [ x.e = 0 ];
        } else {
            x.e = e;
            x.c = [];

            // Transform base

            // e is the base 10 exponent. ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.bignumber.js.BigNumber.another" id="apidoc.element.bignumber.js.BigNumber.another">
        function <span class="apidocSignatureSpan">bignumber.js.BigNumber.</span>another
        <span class="apidocSignatureSpan">(config)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function constructorFactory(config) {
    var div, parseNumeric,

        // id tracks the caller function, so its name can be included in error messages.
        id = 0,
        P = BigNumber.prototype,
        ONE = new BigNumber(1),


        /********************************* EDITABLE DEFAULTS **********************************/


        /*
         * The default values below must be integers within the inclusive ranges stated.
         * The values can also be changed at run-time using BigNumber.config.
         */

        // The maximum number of decimal places for operations involving division.
        DECIMAL_PLACES = 20,                     // 0 to MAX

        /*
         * The rounding mode used when rounding to the above decimal places, and when using
         * toExponential, toFixed, toFormat and toPrecision, and round (default value).
         * UP         0 Away from zero.
         * DOWN       1 Towards zero.
         * CEIL       2 Towards +Infinity.
         * FLOOR      3 Towards -Infinity.
         * HALF_UP    4 Towards nearest neighbour. If equidistant, up.
         * HALF_DOWN  5 Towards nearest neighbour. If equidistant, down.
         * HALF_EVEN  6 Towards nearest neighbour. If equidistant, towards even neighbour.
         * HALF_CEIL  7 Towards nearest neighbour. If equidistant, towards +Infinity.
         * HALF_FLOOR 8 Towards nearest neighbour. If equidistant, towards -Infinity.
         */
        ROUNDING_MODE = 4,                       // 0 to 8

        // EXPONENTIAL_AT : [TO_EXP_NEG , TO_EXP_POS]

        // The exponent value at and beneath which toString returns exponential notation.
        // Number type: -7
        TO_EXP_NEG = -7,                         // 0 to -MAX

        // The exponent value at and above which toString returns exponential notation.
        // Number type: 21
        TO_EXP_POS = 21,                         // 0 to MAX

        // RANGE : [MIN_EXP, MAX_EXP]

        // The minimum exponent value, beneath which underflow to zero occurs.
        // Number type: -324  (5e-324)
        MIN_EXP = -1e7,                          // -1 to -MAX

        // The maximum exponent value, above which overflow to Infinity occurs.
        // Number type:  308  (1.7976931348623157e+308)
        // For MAX_EXP &gt; 1e7, e.g. new BigNumber('1e100000000').plus(1) may be slow.
        MAX_EXP = 1e7,                           // 1 to MAX

        // Whether BigNumber Errors are ever thrown.
        ERRORS = true,                           // true or false

        // Change to intValidatorNoErrors if ERRORS is false.
        isValidInt = intValidatorWithErrors,     // intValidatorWithErrors/intValidatorNoErrors

        // Whether to use cryptographically-secure random number generation, if available.
        CRYPTO = false,                          // true or false

        /*
         * The modulo mode used when calculating the modulus: a mod n.
         * The quotient (q = a / n) is calculated according to the corresponding rounding mode.
         * The remainder (r) is calculated as: r = a - n * q.
         *
         * UP        0 The remainder is positive if the dividend is negative, else is negative.
         * DOWN      1 The remainder has the same sign as the dividend.
         *             This modulo mode is commonly known as 'truncated division' and is
         *             equivalent to (a % n) in JavaScript.
         * FLOOR     3 The remainder has the same sign as the divisor (Python %).
         * HALF_EVEN 6 This modulo mode implements the IEEE 754 remainder function.
         * EUCLID    9 Euclidian division. q = sign(n) * floor(a / abs(n)).
         *             The remainder is always positive.
         *
         * The truncated division, floored division, Euclidian division and IEEE 754 remainder
         * modes are commonly used for the modulus operation.
         * Although the other rounding modes can also be used, they may not give useful results.
         */
        M ...</pre></li>
    <li>example usage<pre class="apidocCodePre">...
Multiple BigNumber constructors can be created, each with their own independent configuration which applies to all BigNumber'
;s created from it.

```javascript
// Set DECIMAL_PLACES for the original BigNumber constructor
BigNumber.config({ DECIMAL_PLACES: 10 })

// Create another BigNumber constructor, optionally passing in a configuration object
BN = BigNumber.<span class="apidocCodeKeywordSpan">another</span>({ DECIMAL_PLACES: 5 })

x = new BigNumber(1)
y = new BN(1)

x.div(3)                            // '0.3333333333'
y.div(3)                            // '0.33333'
```
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.bignumber.js.BigNumber.config" id="apidoc.element.bignumber.js.BigNumber.config">
        function <span class="apidocSignatureSpan">bignumber.js.BigNumber.</span>config
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">config = function () {
    var v, p,
        i = 0,
        r = {},
        a = arguments,
        o = a[0],
        has = o &amp;&amp; typeof o == 'object'
          ? function () { if ( o.hasOwnProperty(p) ) return ( v = o[p] ) != null; }
          : function () { if ( a.length &gt; i ) return ( v = a[i++] ) != null; };

    // DECIMAL_PLACES {number} Integer, 0 to MAX inclusive.
    // 'config() DECIMAL_PLACES not an integer: {v}'
    // 'config() DECIMAL_PLACES out of range: {v}'
    if ( has( p = 'DECIMAL_PLACES' ) &amp;&amp; isValidInt( v, 0, MAX, 2, p ) ) {
        DECIMAL_PLACES = v | 0;
    }
    r[p] = DECIMAL_PLACES;

    // ROUNDING_MODE {number} Integer, 0 to 8 inclusive.
    // 'config() ROUNDING_MODE not an integer: {v}'
    // 'config() ROUNDING_MODE out of range: {v}'
    if ( has( p = 'ROUNDING_MODE' ) &amp;&amp; isValidInt( v, 0, 8, 2, p ) ) {
        ROUNDING_MODE = v | 0;
    }
    r[p] = ROUNDING_MODE;

    // EXPONENTIAL_AT {number|number[]}
    // Integer, -MAX to MAX inclusive or [integer -MAX to 0 inclusive, 0 to MAX inclusive].
    // 'config() EXPONENTIAL_AT not an integer: {v}'
    // 'config() EXPONENTIAL_AT out of range: {v}'
    if ( has( p = 'EXPONENTIAL_AT' ) ) {

        if ( isArray(v) ) {
            if ( isValidInt( v[0], -MAX, 0, 2, p ) &amp;&amp; isValidInt( v[1], 0, MAX, 2, p ) ) {
                TO_EXP_NEG = v[0] | 0;
                TO_EXP_POS = v[1] | 0;
            }
        } else if ( isValidInt( v, -MAX, MAX, 2, p ) ) {
            TO_EXP_NEG = -( TO_EXP_POS = ( v &lt; 0 ? -v : v ) | 0 );
        }
    }
    r[p] = [ TO_EXP_NEG, TO_EXP_POS ];

    // RANGE {number|number[]} Non-zero integer, -MAX to MAX inclusive or
    // [integer -MAX to -1 inclusive, integer 1 to MAX inclusive].
    // 'config() RANGE not an integer: {v}'
    // 'config() RANGE cannot be zero: {v}'
    // 'config() RANGE out of range: {v}'
    if ( has( p = 'RANGE' ) ) {

        if ( isArray(v) ) {
            if ( isValidInt( v[0], -MAX, -1, 2, p ) &amp;&amp; isValidInt( v[1], 1, MAX, 2, p ) ) {
                MIN_EXP = v[0] | 0;
                MAX_EXP = v[1] | 0;
            }
        } else if ( isValidInt( v, -MAX, MAX, 2, p ) ) {
            if ( v | 0 ) MIN_EXP = -( MAX_EXP = ( v &lt; 0 ? -v : v ) | 0 );
            else if (ERRORS) raise( 2, p + ' cannot be zero', v );
        }
    }
    r[p] = [ MIN_EXP, MAX_EXP ];

    // ERRORS {boolean|number} true, false, 1 or 0.
    // 'config() ERRORS not a boolean or binary digit: {v}'
    if ( has( p = 'ERRORS' ) ) {

        if ( v === !!v || v === 1 || v === 0 ) {
            id = 0;
            isValidInt = ( ERRORS = !!v ) ? intValidatorWithErrors : intValidatorNoErrors;
        } else if (ERRORS) {
            raise( 2, p + notBool, v );
        }
    }
    r[p] = ERRORS;

    // CRYPTO {boolean|number} true, false, 1 or 0.
    // 'config() CRYPTO not a boolean or binary digit: {v}'
    // 'config() crypto unavailable: {crypto}'
    if ( has( p = 'CRYPTO' ) ) {

        if ( v === true || v === false || v === 1 || v === 0 ) {
            if (v) {
                v = typeof crypto == 'undefined';
                if ( !v &amp;&amp; crypto &amp;&amp; (crypto.getRandomValues || crypto.randomBytes)) {
                    CRYPTO = true;
                } else if (ERRORS) {
                    raise( 2, 'crypto unavailable', v ? void 0 : crypto );
                } else {
                    CRYPTO = false;
                }
            } else {
                CRYPTO = false;
            }
        } else if (ERRORS) {
            raise( 2, p + notBool, v );
        }
    }
    r[p] = CRYPTO;

    // MODULO_MODE {number} Integer, 0 to 9 inclusive.
    // 'config() MODULO_MODE not an integer: {v}'
    // 'config() MODULO_MODE out of range: {v}'
    if ( has( p = 'MODULO_MODE' ) &amp;&amp; isValidInt( v, 0, 9, 2, p ) ) {
        MODULO_MODE = v | 0;
    }
    r[p] = MODULO_MODE;

    // POW_PRECISION {number} Integer, 0 to MAX inclusive.
    // 'config() POW_PRECISION not an integer: {v}'
    // 'config() POW_PRECISION out of r ...</pre></li>
    <li>example usage<pre class="apidocCodePre">...
```

The maximum number of decimal places of the result of an operation involving division (i.e. a division, square root, base conversion
 or negative power operation) is set using the `config` method of the `BigNumber` constructor.

The other arithmetic operations always give the exact result.

```javascript
BigNumber.<span class="apidocCodeKeywordSpan">config</span>({ DECIMAL_PLACES: 10, ROUNDING_MODE: 4 })

x = new BigNumber(2);
y = new BigNumber(3);
z = x.div(y)                        // "0.6666666667"
z.sqrt()                            // "0.8164965809"
z.pow(-3)                           // "3.3749999995"
z.toString(2)                       // "0.1010101011"
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.bignumber.js.BigNumber.default" id="apidoc.element.bignumber.js.BigNumber.default">
        function <span class="apidocSignatureSpan">bignumber.js.BigNumber.</span>default
        <span class="apidocSignatureSpan">( n, b )</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function BigNumber( n, b ) {
    var c, e, i, num, len, str,
        x = this;

    // Enable constructor usage without new.
    if ( !( x instanceof BigNumber ) ) {

        // 'BigNumber() constructor call without new: {n}'
        if (ERRORS) raise( 26, 'constructor call without new', n );
        return new BigNumber( n, b );
    }

    // 'new BigNumber() base not an integer: {b}'
    // 'new BigNumber() base out of range: {b}'
    if ( b == null || !isValidInt( b, 2, 64, id, 'base' ) ) {

        // Duplicate.
        if ( n instanceof BigNumber ) {
            x.s = n.s;
            x.e = n.e;
            x.c = ( n = n.c ) ? n.slice() : n;
            id = 0;
            return;
        }

        if ( ( num = typeof n == 'number' ) &amp;&amp; n * 0 == 0 ) {
            x.s = 1 / n &lt; 0 ? ( n = -n, -1 ) : 1;

            // Fast path for integers.
            if ( n === ~~n ) {
                for ( e = 0, i = n; i &gt;= 10; i /= 10, e++ );
                x.e = e;
                x.c = [n];
                id = 0;
                return;
            }

            str = n + '';
        } else {
            if ( !isNumeric.test( str = n + '' ) ) return parseNumeric( x, str, num );
            x.s = str.charCodeAt(0) === 45 ? ( str = str.slice(1), -1 ) : 1;
        }
    } else {
        b = b | 0;
        str = n + '';

        // Ensure return value is rounded to DECIMAL_PLACES as with other bases.
        // Allow exponential notation to be used with base 10 argument.
        if ( b == 10 ) {
            x = new BigNumber( n instanceof BigNumber ? n : str );
            return round( x, DECIMAL_PLACES + x.e + 1, ROUNDING_MODE );
        }

        // Avoid potential interpretation of Infinity and NaN as base 44+ values.
        // Any number in exponential form will fail due to the [Ee][+-].
        if ( ( num = typeof n == 'number' ) &amp;&amp; n * 0 != 0 ||
          !( new RegExp( '^-?' + ( c = '[' + ALPHABET.slice( 0, b ) + ']+' ) +
            '(?:\\.' + c + ')?$',b &lt; 37 ? 'i' : '' ) ).test(str) ) {
            return parseNumeric( x, str, num, b );
        }

        if (num) {
            x.s = 1 / n &lt; 0 ? ( str = str.slice(1), -1 ) : 1;

            if ( ERRORS &amp;&amp; str.replace( /^0\.0*|\./, '' ).length &gt; 15 ) {

                // 'new BigNumber() number type has more than 15 significant digits: {n}'
                raise( id, tooManyDigits, n );
            }

            // Prevent later check for length on converted number.
            num = false;
        } else {
            x.s = str.charCodeAt(0) === 45 ? ( str = str.slice(1), -1 ) : 1;
        }

        str = convertBase( str, 10, b, x.s );
    }

    // Decimal point?
    if ( ( e = str.indexOf('.') ) &gt; -1 ) str = str.replace( '.', '' );

    // Exponential form?
    if ( ( i = str.search( /e/i ) ) &gt; 0 ) {

        // Determine exponent.
        if ( e &lt; 0 ) e = i;
        e += +str.slice( i + 1 );
        str = str.substring( 0, i );
    } else if ( e &lt; 0 ) {

        // Integer.
        e = str.length;
    }

    // Determine leading zeros.
    for ( i = 0; str.charCodeAt(i) === 48; i++ );

    // Determine trailing zeros.
    for ( len = str.length; str.charCodeAt(--len) === 48; );
    str = str.slice( i, len + 1 );

    if (str) {
        len = str.length;

        // Disallow numbers with over 15 significant digits if number type.
        // 'new BigNumber() number type has more than 15 significant digits: {n}'
        if ( num &amp;&amp; ERRORS &amp;&amp; len &gt; 15 &amp;&amp; ( n &gt; MAX_SAFE_INTEGER || n !== mathfloor(n) ) ) {
            raise( id, tooManyDigits, x.s * n );
        }

        e = e - i - 1;

         // Overflow?
        if ( e &gt; MAX_EXP ) {

            // Infinity.
            x.c = x.e = null;

        // Underflow?
        } else if ( e &lt; MIN_EXP ) {

            // Zero.
            x.c = [ x.e = 0 ];
        } else {
            x.e = e;
            x.c = [];

            // Transform base

            // e is the base 10 exponent. ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.bignumber.js.BigNumber.max" id="apidoc.element.bignumber.js.BigNumber.max">
        function <span class="apidocSignatureSpan">bignumber.js.BigNumber.</span>max
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">max = function () { return maxOrMin( arguments, P.lt ); }</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.bignumber.js.BigNumber.min" id="apidoc.element.bignumber.js.BigNumber.min">
        function <span class="apidocSignatureSpan">bignumber.js.BigNumber.</span>min
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">min = function () { return maxOrMin( arguments, P.gt ); }</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.bignumber.js.BigNumber.random" id="apidoc.element.bignumber.js.BigNumber.random">
        function <span class="apidocSignatureSpan">bignumber.js.BigNumber.</span>random
        <span class="apidocSignatureSpan">(dp)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">random = function (dp) {
    var a, b, e, k, v,
        i = 0,
        c = [],
        rand = new BigNumber(ONE);

    dp = dp == null || !isValidInt( dp, 0, MAX, 14 ) ? DECIMAL_PLACES : dp | 0;
    k = mathceil( dp / LOG_BASE );

    if (CRYPTO) {

        // Browsers supporting crypto.getRandomValues.
        if (crypto.getRandomValues) {

            a = crypto.getRandomValues( new Uint32Array( k *= 2 ) );

            for ( ; i &lt; k; ) {

                // 53 bits:
                // ((Math.pow(2, 32) - 1) * Math.pow(2, 21)).toString(2)
                // 11111 11111111 11111111 11111111 11100000 00000000 00000000
                // ((Math.pow(2, 32) - 1) &gt;&gt;&gt; 11).toString(2)
                //                                     11111 11111111 11111111
                // 0x20000 is 2^21.
                v = a[i] * 0x20000 + (a[i + 1] &gt;&gt;&gt; 11);

                // Rejection sampling:
                // 0 &lt;= v &lt; 9007199254740992
                // Probability that v &gt;= 9e15, is
                // 7199254740992 / 9007199254740992 ~= 0.0008, i.e. 1 in 1251
                if ( v &gt;= 9e15 ) {
                    b = crypto.getRandomValues( new Uint32Array(2) );
                    a[i] = b[0];
                    a[i + 1] = b[1];
                } else {

                    // 0 &lt;= v &lt;= 8999999999999999
                    // 0 &lt;= (v % 1e14) &lt;= 99999999999999
                    c.push( v % 1e14 );
                    i += 2;
                }
            }
            i = k / 2;

        // Node.js supporting crypto.randomBytes.
        } else if (crypto.randomBytes) {

            // buffer
            a = crypto.randomBytes( k *= 7 );

            for ( ; i &lt; k; ) {

                // 0x1000000000000 is 2^48, 0x10000000000 is 2^40
                // 0x100000000 is 2^32, 0x1000000 is 2^24
                // 11111 11111111 11111111 11111111 11111111 11111111 11111111
                // 0 &lt;= v &lt; 9007199254740992
                v = ( ( a[i] &amp; 31 ) * 0x1000000000000 ) + ( a[i + 1] * 0x10000000000 ) +
                      ( a[i + 2] * 0x100000000 ) + ( a[i + 3] * 0x1000000 ) +
                      ( a[i + 4] &lt;&lt; 16 ) + ( a[i + 5] &lt;&lt; 8 ) + a[i + 6];

                if ( v &gt;= 9e15 ) {
                    crypto.randomBytes(7).copy( a, i );
                } else {

                    // 0 &lt;= (v % 1e14) &lt;= 99999999999999
                    c.push( v % 1e14 );
                    i += 7;
                }
            }
            i = k / 7;
        } else {
            CRYPTO = false;
            if (ERRORS) raise( 14, 'crypto unavailable', crypto );
        }
    }

    // Use Math.random.
    if (!CRYPTO) {

        for ( ; i &lt; k; ) {
            v = random53bitInt();
            if ( v &lt; 9e15 ) c[i++] = v % 1e14;
        }
    }

    k = c[--i];
    dp %= LOG_BASE;

    // Convert trailing digits to zeros according to dp.
    if ( k &amp;&amp; dp ) {
        v = POWS_TEN[LOG_BASE - dp];
        c[i] = mathfloor( k / v ) * v;
    }

    // Remove trailing elements which are zero.
    for ( ; c[i] === 0; c.pop(), i-- );

    // Zero?
    if ( i &lt; 0 ) {
        c = [ e = 0 ];
    } else {

        // Remove leading elements which are zero and adjust exponent accordingly.
        for ( e = -1 ; c[0] === 0; c.shift(), e -= LOG_BASE);

        // Count the digits of the first element of c to determine leading zeros, and...
        for ( i = 1, v = c[0]; v &gt;= 10; v /= 10, i++);

        // adjust the exponent accordingly.
        if ( i &lt; LOG_BASE ) e -= LOG_BASE - i;
    }

    rand.e = e;
    rand.c = c;
    return rand;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
         * 'random() decimal places out of range: {dp}'
         * 'random() crypto unavailable: {crypto}'
         */
        BigNumber.random = (function () {
var pow2_53 = 0x20000000000000;

// Return a 53 bit integer n, where 0 &lt;= n &lt; 9007199254740992.
// Check if Math.<span class="apidocCodeKeywordSpan">random</span>() produces more than 32 bits of randomness.
// If it does, assume at least 53 bits are produced, otherwise assume at least 30 bits.
// 0x40000000 is 2^30, 0x800000 is 2^23, 0x1fffff is 2^21 - 1.
var random53bitInt = (Math.random() * pow2_53) &amp; 0x1fffff
  ? function () { return mathfloor( Math.random() * pow2_53 ); }
  : function () { return ((Math.random() * 0x40000000 | 0) * 0x800000) +
      (Math.random() * 0x800000 | 0); };
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.bignumber.js.BigNumber.set" id="apidoc.element.bignumber.js.BigNumber.set">
        function <span class="apidocSignatureSpan">bignumber.js.BigNumber.</span>set
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">set = function () {
    var v, p,
        i = 0,
        r = {},
        a = arguments,
        o = a[0],
        has = o &amp;&amp; typeof o == 'object'
          ? function () { if ( o.hasOwnProperty(p) ) return ( v = o[p] ) != null; }
          : function () { if ( a.length &gt; i ) return ( v = a[i++] ) != null; };

    // DECIMAL_PLACES {number} Integer, 0 to MAX inclusive.
    // 'config() DECIMAL_PLACES not an integer: {v}'
    // 'config() DECIMAL_PLACES out of range: {v}'
    if ( has( p = 'DECIMAL_PLACES' ) &amp;&amp; isValidInt( v, 0, MAX, 2, p ) ) {
        DECIMAL_PLACES = v | 0;
    }
    r[p] = DECIMAL_PLACES;

    // ROUNDING_MODE {number} Integer, 0 to 8 inclusive.
    // 'config() ROUNDING_MODE not an integer: {v}'
    // 'config() ROUNDING_MODE out of range: {v}'
    if ( has( p = 'ROUNDING_MODE' ) &amp;&amp; isValidInt( v, 0, 8, 2, p ) ) {
        ROUNDING_MODE = v | 0;
    }
    r[p] = ROUNDING_MODE;

    // EXPONENTIAL_AT {number|number[]}
    // Integer, -MAX to MAX inclusive or [integer -MAX to 0 inclusive, 0 to MAX inclusive].
    // 'config() EXPONENTIAL_AT not an integer: {v}'
    // 'config() EXPONENTIAL_AT out of range: {v}'
    if ( has( p = 'EXPONENTIAL_AT' ) ) {

        if ( isArray(v) ) {
            if ( isValidInt( v[0], -MAX, 0, 2, p ) &amp;&amp; isValidInt( v[1], 0, MAX, 2, p ) ) {
                TO_EXP_NEG = v[0] | 0;
                TO_EXP_POS = v[1] | 0;
            }
        } else if ( isValidInt( v, -MAX, MAX, 2, p ) ) {
            TO_EXP_NEG = -( TO_EXP_POS = ( v &lt; 0 ? -v : v ) | 0 );
        }
    }
    r[p] = [ TO_EXP_NEG, TO_EXP_POS ];

    // RANGE {number|number[]} Non-zero integer, -MAX to MAX inclusive or
    // [integer -MAX to -1 inclusive, integer 1 to MAX inclusive].
    // 'config() RANGE not an integer: {v}'
    // 'config() RANGE cannot be zero: {v}'
    // 'config() RANGE out of range: {v}'
    if ( has( p = 'RANGE' ) ) {

        if ( isArray(v) ) {
            if ( isValidInt( v[0], -MAX, -1, 2, p ) &amp;&amp; isValidInt( v[1], 1, MAX, 2, p ) ) {
                MIN_EXP = v[0] | 0;
                MAX_EXP = v[1] | 0;
            }
        } else if ( isValidInt( v, -MAX, MAX, 2, p ) ) {
            if ( v | 0 ) MIN_EXP = -( MAX_EXP = ( v &lt; 0 ? -v : v ) | 0 );
            else if (ERRORS) raise( 2, p + ' cannot be zero', v );
        }
    }
    r[p] = [ MIN_EXP, MAX_EXP ];

    // ERRORS {boolean|number} true, false, 1 or 0.
    // 'config() ERRORS not a boolean or binary digit: {v}'
    if ( has( p = 'ERRORS' ) ) {

        if ( v === !!v || v === 1 || v === 0 ) {
            id = 0;
            isValidInt = ( ERRORS = !!v ) ? intValidatorWithErrors : intValidatorNoErrors;
        } else if (ERRORS) {
            raise( 2, p + notBool, v );
        }
    }
    r[p] = ERRORS;

    // CRYPTO {boolean|number} true, false, 1 or 0.
    // 'config() CRYPTO not a boolean or binary digit: {v}'
    // 'config() crypto unavailable: {crypto}'
    if ( has( p = 'CRYPTO' ) ) {

        if ( v === true || v === false || v === 1 || v === 0 ) {
            if (v) {
                v = typeof crypto == 'undefined';
                if ( !v &amp;&amp; crypto &amp;&amp; (crypto.getRandomValues || crypto.randomBytes)) {
                    CRYPTO = true;
                } else if (ERRORS) {
                    raise( 2, 'crypto unavailable', v ? void 0 : crypto );
                } else {
                    CRYPTO = false;
                }
            } else {
                CRYPTO = false;
            }
        } else if (ERRORS) {
            raise( 2, p + notBool, v );
        }
    }
    r[p] = CRYPTO;

    // MODULO_MODE {number} Integer, 0 to 9 inclusive.
    // 'config() MODULO_MODE not an integer: {v}'
    // 'config() MODULO_MODE out of range: {v}'
    if ( has( p = 'MODULO_MODE' ) &amp;&amp; isValidInt( v, 0, 9, 2, p ) ) {
        MODULO_MODE = v | 0;
    }
    r[p] = MODULO_MODE;

    // POW_PRECISION {number} Integer, 0 to MAX inclusive.
    // 'config() POW_PRECISION not an integer: {v}'
    // 'config() POW_PRECISION out of r ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>






















</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.bignumber.js.BigNumber.prototype" id="apidoc.module.bignumber.js.BigNumber.prototype">module bignumber.js.BigNumber.prototype</a></h1>




    <h2>
        <a href="#apidoc.element.bignumber.js.BigNumber.prototype.abs" id="apidoc.element.bignumber.js.BigNumber.prototype.abs">
        function <span class="apidocSignatureSpan">bignumber.js.BigNumber.prototype.</span>abs
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">abs = function () {
    var x = new BigNumber(this);
    if ( x.s &lt; 0 ) x.s = 1;
    return x;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    d2 = div( md.minus(d0), d1, 0, 1 );
    n0 = n0.plus( d2.times(n1) );
    d0 = d0.plus( d2.times(d1) );
    n0.s = n1.s = x.s;
    e *= 2;

    // Determine which fraction is closer to x, n0/d0 or n1/d1
    arr = div( n1, d1, e, ROUNDING_MODE ).minus(x).<span class="apidocCodeKeywordSpan">abs</span>().cmp(
          div( n0, d0, e, ROUNDING_MODE ).minus(x).abs() ) &lt; 1
            ? [ n1.toString(), d1.toString() ]
            : [ n0.toString(), d0.toString() ];

    MAX_EXP = exp;
    return arr;
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.bignumber.js.BigNumber.prototype.absoluteValue" id="apidoc.element.bignumber.js.BigNumber.prototype.absoluteValue">
        function <span class="apidocSignatureSpan">bignumber.js.BigNumber.prototype.</span>absoluteValue
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">absoluteValue = function () {
    var x = new BigNumber(this);
    if ( x.s &lt; 0 ) x.s = 1;
    return x;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.bignumber.js.BigNumber.prototype.add" id="apidoc.element.bignumber.js.BigNumber.prototype.add">
        function <span class="apidocSignatureSpan">bignumber.js.BigNumber.prototype.</span>add
        <span class="apidocSignatureSpan">( y, b )</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">add = function ( y, b ) {
    var t,
        x = this,
        a = x.s;

    id = 12;
    y = new BigNumber( y, b );
    b = y.s;

    // Either NaN?
    if ( !a || !b ) return new BigNumber(NaN);

    // Signs differ?
     if ( a != b ) {
        y.s = -b;
        return x.minus(y);
    }

    var xe = x.e / LOG_BASE,
        ye = y.e / LOG_BASE,
        xc = x.c,
        yc = y.c;

    if ( !xe || !ye ) {

        // Return Infinity if either Infinity.
        if ( !xc || !yc ) return new BigNumber( a / 0 );

        // Either zero?
        // Return y if y is non-zero, x if x is non-zero, or zero if both are zero.
        if ( !xc[0] || !yc[0] ) return yc[0] ? y : new BigNumber( xc[0] ? x : a * 0 );
    }

    xe = bitFloor(xe);
    ye = bitFloor(ye);
    xc = xc.slice();

    // Prepend zeros to equalise exponents. Faster to use reverse then do unshifts.
    if ( a = xe - ye ) {
        if ( a &gt; 0 ) {
            ye = xe;
            t = yc;
        } else {
            a = -a;
            t = xc;
        }

        t.reverse();
        for ( ; a--; t.push(0) );
        t.reverse();
    }

    a = xc.length;
    b = yc.length;

    // Point xc to the longer array, and b to the shorter length.
    if ( a - b &lt; 0 ) t = yc, yc = xc, xc = t, b = a;

    // Only start adding at yc.length - 1 as the further digits of xc can be ignored.
    for ( a = 0; b; ) {
        a = ( xc[--b] = xc[b] + yc[b] + a ) / BASE | 0;
        xc[b] = BASE === xc[b] ? 0 : xc[b] % BASE;
    }

    if (a) {
        xc.unshift(a);
        ++ye;
    }

    // No need to check for zero, as +x + +y != 0 &amp;&amp; -x + -y != 0
    // ye = MAX_EXP + 1 possible
    return normalise( y, xc, ye );
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.bignumber.js.BigNumber.prototype.ceil" id="apidoc.element.bignumber.js.BigNumber.prototype.ceil">
        function <span class="apidocSignatureSpan">bignumber.js.BigNumber.prototype.</span>ceil
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ceil = function () {
    return round( new BigNumber(this), this.e + 1, 2 );
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
x                                   // "0.3"
```

The methods that return a BigNumber can be chained.

```javascript
x.dividedBy(y).plus(z).times(9).floor()
x.times('1.23456780123456789e+9').plus(9876.5432321).dividedBy('4444562598.111772').<span class="apidocCodeKeywordSpan
">ceil</span>()
```

Many method names have a shorter alias.

```javascript
x.squareRoot().dividedBy(y).toPower(3).equals(x.sqrt().div(y).pow(3))         // true
x.cmp(y.mod(z).neg()) == 1 &amp;&amp; x.comparedTo(y.modulo(z).negated()) == 1        // true
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.bignumber.js.BigNumber.prototype.cmp" id="apidoc.element.bignumber.js.BigNumber.prototype.cmp">
        function <span class="apidocSignatureSpan">bignumber.js.BigNumber.prototype.</span>cmp
        <span class="apidocSignatureSpan">( y, b )</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">cmp = function ( y, b ) {
    id = 1;
    return compare( this, new BigNumber( y, b ) );
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
x.times('1.23456780123456789e+9').plus(9876.5432321).dividedBy('4444562598.111772').ceil()
```

Many method names have a shorter alias.

```javascript
x.squareRoot().dividedBy(y).toPower(3).equals(x.sqrt().div(y).pow(3))         // true
x.<span class="apidocCodeKeywordSpan">cmp</span>(y.mod(z).neg()) == 1 &amp;&amp; x.comparedTo(y.modulo(z).negated()) == 1        //
true
```

Like JavaScript's number type, there are `toExponential`, `toFixed` and `toPrecision` methods

```javascript
x = new BigNumber(255.5)
x.toExponential(5)                  // "2.55500e+2"
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.bignumber.js.BigNumber.prototype.comparedTo" id="apidoc.element.bignumber.js.BigNumber.prototype.comparedTo">
        function <span class="apidocSignatureSpan">bignumber.js.BigNumber.prototype.</span>comparedTo
        <span class="apidocSignatureSpan">( y, b )</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">comparedTo = function ( y, b ) {
    id = 1;
    return compare( this, new BigNumber( y, b ) );
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
x.times('1.23456780123456789e+9').plus(9876.5432321).dividedBy('4444562598.111772').ceil()
```

Many method names have a shorter alias.

```javascript
x.squareRoot().dividedBy(y).toPower(3).equals(x.sqrt().div(y).pow(3))         // true
x.cmp(y.mod(z).neg()) == 1 &amp;&amp; x.<span class="apidocCodeKeywordSpan">comparedTo</span>(y.modulo(z).negated()) == 1        //
true
```

Like JavaScript's number type, there are `toExponential`, `toFixed` and `toPrecision` methods

```javascript
x = new BigNumber(255.5)
x.toExponential(5)                  // "2.55500e+2"
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.bignumber.js.BigNumber.prototype.decimalPlaces" id="apidoc.element.bignumber.js.BigNumber.prototype.decimalPlaces">
        function <span class="apidocSignatureSpan">bignumber.js.BigNumber.prototype.</span>decimalPlaces
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">decimalPlaces = function () {
    var n, v,
        c = this.c;

    if ( !c ) return null;
    n = ( ( v = c.length - 1 ) - bitFloor( this.e / LOG_BASE ) ) * LOG_BASE;

    // Subtract the number of trailing zeros of the last number.
    if ( v = c[v] ) for ( ; v % 10 == 0; v /= 10, n-- );
    if ( n &lt; 0 ) n = 0;

    return n;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.bignumber.js.BigNumber.prototype.div" id="apidoc.element.bignumber.js.BigNumber.prototype.div">
        function <span class="apidocSignatureSpan">bignumber.js.BigNumber.prototype.</span>div
        <span class="apidocSignatureSpan">( y, b )</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">div = function ( y, b ) {
    id = 3;
    return div( this, new BigNumber( y, b ), DECIMAL_PLACES, ROUNDING_MODE );
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
x.dividedBy(y).plus(z).times(9).floor()
x.times('1.23456780123456789e+9').plus(9876.5432321).dividedBy('4444562598.111772').ceil()
```

Many method names have a shorter alias.

```javascript
x.squareRoot().dividedBy(y).toPower(3).equals(x.sqrt().<span class="apidocCodeKeywordSpan">div</span>(y).pow(3))         // true
x.cmp(y.mod(z).neg()) == 1 &amp;&amp; x.comparedTo(y.modulo(z).negated()) == 1        // true
```

Like JavaScript's number type, there are `toExponential`, `toFixed` and `toPrecision` methods

```javascript
x = new BigNumber(255.5)
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.bignumber.js.BigNumber.prototype.divToInt" id="apidoc.element.bignumber.js.BigNumber.prototype.divToInt">
        function <span class="apidocSignatureSpan">bignumber.js.BigNumber.prototype.</span>divToInt
        <span class="apidocSignatureSpan">( y, b )</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">divToInt = function ( y, b ) {
    id = 4;
    return div( this, new BigNumber( y, b ), 0, 1 );
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.bignumber.js.BigNumber.prototype.dividedBy" id="apidoc.element.bignumber.js.BigNumber.prototype.dividedBy">
        function <span class="apidocSignatureSpan">bignumber.js.BigNumber.prototype.</span>dividedBy
        <span class="apidocSignatureSpan">( y, b )</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">dividedBy = function ( y, b ) {
    id = 3;
    return div( this, new BigNumber( y, b ), DECIMAL_PLACES, ROUNDING_MODE );
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
x.minus(0.1)                        // "0.2"
x                                   // "0.3"
```

The methods that return a BigNumber can be chained.

```javascript
x.<span class="apidocCodeKeywordSpan">dividedBy</span>(y).plus(z).times(9).floor()
x.times('1.23456780123456789e+9').plus(9876.5432321).dividedBy('4444562598.111772').ceil()
```

Many method names have a shorter alias.

```javascript
x.squareRoot().dividedBy(y).toPower(3).equals(x.sqrt().div(y).pow(3))         // true
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.bignumber.js.BigNumber.prototype.dividedToIntegerBy" id="apidoc.element.bignumber.js.BigNumber.prototype.dividedToIntegerBy">
        function <span class="apidocSignatureSpan">bignumber.js.BigNumber.prototype.</span>dividedToIntegerBy
        <span class="apidocSignatureSpan">( y, b )</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">dividedToIntegerBy = function ( y, b ) {
    id = 4;
    return div( this, new BigNumber( y, b ), 0, 1 );
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.bignumber.js.BigNumber.prototype.dp" id="apidoc.element.bignumber.js.BigNumber.prototype.dp">
        function <span class="apidocSignatureSpan">bignumber.js.BigNumber.prototype.</span>dp
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">dp = function () {
    var n, v,
        c = this.c;

    if ( !c ) return null;
    n = ( ( v = c.length - 1 ) - bitFloor( this.e / LOG_BASE ) ) * LOG_BASE;

    // Subtract the number of trailing zeros of the last number.
    if ( v = c[v] ) for ( ; v % 10 == 0; v /= 10, n-- );
    if ( n &lt; 0 ) n = 0;

    return n;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.bignumber.js.BigNumber.prototype.eq" id="apidoc.element.bignumber.js.BigNumber.prototype.eq">
        function <span class="apidocSignatureSpan">bignumber.js.BigNumber.prototype.</span>eq
        <span class="apidocSignatureSpan">( y, b )</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">eq = function ( y, b ) {
    id = 5;
    return compare( this, new BigNumber( y, b ) ) === 0;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
                        if ( n == '9999' || !rep &amp;&amp; n == '4999' ) {

// On the first iteration only, check to see if rounding up gives the
// exact result as the nines may infinitely repeat.
if ( !rep ) {
    round( t, t.e + DECIMAL_PLACES + 2, 0 );

    if ( t.times(t).<span class="apidocCodeKeywordSpan">eq</span>(x) ) {
        r = t;
        break;
    }
}

dp += 4;
s += 4;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.bignumber.js.BigNumber.prototype.equals" id="apidoc.element.bignumber.js.BigNumber.prototype.equals">
        function <span class="apidocSignatureSpan">bignumber.js.BigNumber.prototype.</span>equals
        <span class="apidocSignatureSpan">( y, b )</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">equals = function ( y, b ) {
    id = 5;
    return compare( this, new BigNumber( y, b ) ) === 0;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

It accepts a value of type number *(up to 15 significant digits only)*, string or BigNumber object,

```javascript
x = new BigNumber(123.4567)
y = BigNumber('123456.7e-3')
z = new BigNumber(x)
x.<span class="apidocCodeKeywordSpan">equals</span>(y) &amp;&amp; y.equals(z) &amp;&amp; x.equals(z)      // true
```


and a base from 2 to 64 inclusive can be specified.

```javascript
x = new BigNumber(1011, 2)          // "11"
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.bignumber.js.BigNumber.prototype.floor" id="apidoc.element.bignumber.js.BigNumber.prototype.floor">
        function <span class="apidocSignatureSpan">bignumber.js.BigNumber.prototype.</span>floor
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">floor = function () {
    return round( new BigNumber(this), this.e + 1, 3 );
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
x.minus(0.1)                        // "0.2"
x                                   // "0.3"
```

The methods that return a BigNumber can be chained.

```javascript
x.dividedBy(y).plus(z).times(9).<span class="apidocCodeKeywordSpan">floor</span>()
x.times('1.23456780123456789e+9').plus(9876.5432321).dividedBy('4444562598.111772').ceil()
```

Many method names have a shorter alias.

```javascript
x.squareRoot().dividedBy(y).toPower(3).equals(x.sqrt().div(y).pow(3))         // true
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.bignumber.js.BigNumber.prototype.greaterThan" id="apidoc.element.bignumber.js.BigNumber.prototype.greaterThan">
        function <span class="apidocSignatureSpan">bignumber.js.BigNumber.prototype.</span>greaterThan
        <span class="apidocSignatureSpan">( y, b )</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">greaterThan = function ( y, b ) {
    id = 6;
    return compare( this, new BigNumber( y, b ) ) &gt; 0;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.bignumber.js.BigNumber.prototype.greaterThanOrEqualTo" id="apidoc.element.bignumber.js.BigNumber.prototype.greaterThanOrEqualTo">
        function <span class="apidocSignatureSpan">bignumber.js.BigNumber.prototype.</span>greaterThanOrEqualTo
        <span class="apidocSignatureSpan">( y, b )</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">greaterThanOrEqualTo = function ( y, b ) {
    id = 7;
    return ( b = compare( this, new BigNumber( y, b ) ) ) === 1 || b === 0;

}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.bignumber.js.BigNumber.prototype.gt" id="apidoc.element.bignumber.js.BigNumber.prototype.gt">
        function <span class="apidocSignatureSpan">bignumber.js.BigNumber.prototype.</span>gt
        <span class="apidocSignatureSpan">( y, b )</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">gt = function ( y, b ) {
    id = 6;
    return compare( this, new BigNumber( y, b ) ) &gt; 0;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
              ( !isFinite(n) || i &gt; MAX_SAFE_INTEGER &amp;&amp; ( n /= 0 ) ||
parseFloat(n) != n &amp;&amp; !( n = NaN ) ) || n == 0 ) {
k = Math.pow( +x, n );
return new BigNumber( m ? k % m : k );
            }

            if (m) {
if ( n &gt; 1 &amp;&amp; x.<span class="apidocCodeKeywordSpan">gt</span>(ONE) &amp;&amp; x.isInt() &amp;&amp; m.gt(ONE) &amp;#
x26;&amp; m.isInt() ) {
    x = x.mod(m);
} else {
    z = m;

    // Nullify m so only a single mod operation is performed at the end.
    m = null;
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.bignumber.js.BigNumber.prototype.gte" id="apidoc.element.bignumber.js.BigNumber.prototype.gte">
        function <span class="apidocSignatureSpan">bignumber.js.BigNumber.prototype.</span>gte
        <span class="apidocSignatureSpan">( y, b )</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">gte = function ( y, b ) {
    id = 7;
    return ( b = compare( this, new BigNumber( y, b ) ) ) === 1 || b === 0;

}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        if (ERRORS) {
            raise( 22,
              'max denominator ' + ( k ? 'out of range' : 'not an integer' ), md );
        }

        // ERRORS is false:
        // If md is a finite non-integer &gt;= 1, round it to an integer and use it.
        md = !k &amp;&amp; n.c &amp;&amp; round( n, n.e + 1, 1 ).<span class="apidocCodeKeywordSpan">gte</span>(ONE) ? n : null
;
    }
}

if ( !xc ) return x.toString();
s = coeffToString(xc);

// Determine initial denominator.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.bignumber.js.BigNumber.prototype.isFinite" id="apidoc.element.bignumber.js.BigNumber.prototype.isFinite">
        function <span class="apidocSignatureSpan">bignumber.js.BigNumber.prototype.</span>isFinite
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isFinite = function () {
    return !!this.c;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
```

and `isNaN` and `isFinite` methods, as `NaN` and `Infinity` are valid `BigNumber` values.

```javascript
x = new BigNumber(NaN)                                           // "NaN"
y = new BigNumber(Infinity)                                      // "Infinity"
x.isNaN() &amp;&amp; !y.isNaN() &amp;&amp; !x.<span class="apidocCodeKeywordSpan">isFinite</span>() &amp;&amp; !y.isFinite
()        // true
```

The value of a BigNumber is stored in a decimal floating point format in terms of a coefficient, exponent and sign.


```javascript
x = new BigNumber(-123.456);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.bignumber.js.BigNumber.prototype.isInt" id="apidoc.element.bignumber.js.BigNumber.prototype.isInt">
        function <span class="apidocSignatureSpan">bignumber.js.BigNumber.prototype.</span>isInt
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isInt = function () {
    return !!this.c &amp;&amp; bitFloor( this.e / LOG_BASE ) &gt; this.c.length - 2;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
                d1 = n0 = new BigNumber(ONE);

            if ( md != null ) {
                ERRORS = false;
                n = new BigNumber(md);
                ERRORS = k;

                if ( !( k = n.<span class="apidocCodeKeywordSpan">isInt</span>() ) || n.lt(ONE) ) {

if (ERRORS) {
    raise( 22,
      'max denominator ' + ( k ? 'out of range' : 'not an integer' ), md );
}

// ERRORS is false:
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.bignumber.js.BigNumber.prototype.isInteger" id="apidoc.element.bignumber.js.BigNumber.prototype.isInteger">
        function <span class="apidocSignatureSpan">bignumber.js.BigNumber.prototype.</span>isInteger
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isInteger = function () {
    return !!this.c &amp;&amp; bitFloor( this.e / LOG_BASE ) &gt; this.c.length - 2;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.bignumber.js.BigNumber.prototype.isNaN" id="apidoc.element.bignumber.js.BigNumber.prototype.isNaN">
        function <span class="apidocSignatureSpan">bignumber.js.BigNumber.prototype.</span>isNaN
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isNaN = function () {
    return !this.s;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
```

and `isNaN` and `isFinite` methods, as `NaN` and `Infinity` are valid `BigNumber` values.

```javascript
x = new BigNumber(NaN)                                           // "NaN"
y = new BigNumber(Infinity)                                      // "Infinity"
x.<span class="apidocCodeKeywordSpan">isNaN</span>() &amp;&amp; !y.isNaN() &amp;&amp; !x.isFinite() &amp;&amp; !y.isFinite
()        // true
```

The value of a BigNumber is stored in a decimal floating point format in terms of a coefficient, exponent and sign.


```javascript
x = new BigNumber(-123.456);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.bignumber.js.BigNumber.prototype.isNeg" id="apidoc.element.bignumber.js.BigNumber.prototype.isNeg">
        function <span class="apidocSignatureSpan">bignumber.js.BigNumber.prototype.</span>isNeg
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isNeg = function () {
    return this.s &lt; 0;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.bignumber.js.BigNumber.prototype.isNegative" id="apidoc.element.bignumber.js.BigNumber.prototype.isNegative">
        function <span class="apidocSignatureSpan">bignumber.js.BigNumber.prototype.</span>isNegative
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isNegative = function () {
    return this.s &lt; 0;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.bignumber.js.BigNumber.prototype.isZero" id="apidoc.element.bignumber.js.BigNumber.prototype.isZero">
        function <span class="apidocSignatureSpan">bignumber.js.BigNumber.prototype.</span>isZero
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isZero = function () {
    return !!this.c &amp;&amp; this.c[0] == 0;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.bignumber.js.BigNumber.prototype.lessThan" id="apidoc.element.bignumber.js.BigNumber.prototype.lessThan">
        function <span class="apidocSignatureSpan">bignumber.js.BigNumber.prototype.</span>lessThan
        <span class="apidocSignatureSpan">( y, b )</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">lessThan = function ( y, b ) {
    id = 8;
    return compare( this, new BigNumber( y, b ) ) &lt; 0;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.bignumber.js.BigNumber.prototype.lessThanOrEqualTo" id="apidoc.element.bignumber.js.BigNumber.prototype.lessThanOrEqualTo">
        function <span class="apidocSignatureSpan">bignumber.js.BigNumber.prototype.</span>lessThanOrEqualTo
        <span class="apidocSignatureSpan">( y, b )</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">lessThanOrEqualTo = function ( y, b ) {
    id = 9;
    return ( b = compare( this, new BigNumber( y, b ) ) ) === -1 || b === 0;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.bignumber.js.BigNumber.prototype.lt" id="apidoc.element.bignumber.js.BigNumber.prototype.lt">
        function <span class="apidocSignatureSpan">bignumber.js.BigNumber.prototype.</span>lt
        <span class="apidocSignatureSpan">( y, b )</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">lt = function ( y, b ) {
    id = 8;
    return compare( this, new BigNumber( y, b ) ) &lt; 0;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
                d1 = n0 = new BigNumber(ONE);

            if ( md != null ) {
                ERRORS = false;
                n = new BigNumber(md);
                ERRORS = k;

                if ( !( k = n.isInt() ) || n.<span class="apidocCodeKeywordSpan">lt</span>(ONE) ) {

if (ERRORS) {
    raise( 22,
      'max denominator ' + ( k ? 'out of range' : 'not an integer' ), md );
}

// ERRORS is false:
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.bignumber.js.BigNumber.prototype.lte" id="apidoc.element.bignumber.js.BigNumber.prototype.lte">
        function <span class="apidocSignatureSpan">bignumber.js.BigNumber.prototype.</span>lte
        <span class="apidocSignatureSpan">( y, b )</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">lte = function ( y, b ) {
    id = 9;
    return ( b = compare( this, new BigNumber( y, b ) ) ) === -1 || b === 0;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.bignumber.js.BigNumber.prototype.minus" id="apidoc.element.bignumber.js.BigNumber.prototype.minus">
        function <span class="apidocSignatureSpan">bignumber.js.BigNumber.prototype.</span>minus
        <span class="apidocSignatureSpan">( y, b )</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">minus = function ( y, b ) {
    var i, j, t, xLTy,
        x = this,
        a = x.s;

    id = 10;
    y = new BigNumber( y, b );
    b = y.s;

    // Either NaN?
    if ( !a || !b ) return new BigNumber(NaN);

    // Signs differ?
    if ( a != b ) {
        y.s = -b;
        return x.plus(y);
    }

    var xe = x.e / LOG_BASE,
        ye = y.e / LOG_BASE,
        xc = x.c,
        yc = y.c;

    if ( !xe || !ye ) {

        // Either Infinity?
        if ( !xc || !yc ) return xc ? ( y.s = -b, y ) : new BigNumber( yc ? x : NaN );

        // Either zero?
        if ( !xc[0] || !yc[0] ) {

            // Return y if y is non-zero, x if x is non-zero, or zero if both are zero.
            return yc[0] ? ( y.s = -b, y ) : new BigNumber( xc[0] ? x :

              // IEEE 754 (2008) 6.3: n - n = -0 when rounding to -Infinity
              ROUNDING_MODE == 3 ? -0 : 0 );
        }
    }

    xe = bitFloor(xe);
    ye = bitFloor(ye);
    xc = xc.slice();

    // Determine which is the bigger number.
    if ( a = xe - ye ) {

        if ( xLTy = a &lt; 0 ) {
            a = -a;
            t = xc;
        } else {
            ye = xe;
            t = yc;
        }

        t.reverse();

        // Prepend zeros to equalise exponents.
        for ( b = a; b--; t.push(0) );
        t.reverse();
    } else {

        // Exponents equal. Check digit by digit.
        j = ( xLTy = ( a = xc.length ) &lt; ( b = yc.length ) ) ? a : b;

        for ( a = b = 0; b &lt; j; b++ ) {

            if ( xc[b] != yc[b] ) {
                xLTy = xc[b] &lt; yc[b];
                break;
            }
        }
    }

    // x &lt; y? Point xc to the array of the bigger number.
    if (xLTy) t = xc, xc = yc, yc = t, y.s = -y.s;

    b = ( j = yc.length ) - ( i = xc.length );

    // Append zeros to xc if shorter.
    // No need to add zeros to yc if shorter as subtract only needs to start at yc.length.
    if ( b &gt; 0 ) for ( ; b--; xc[i++] = 0 );
    b = BASE - 1;

    // Subtract yc from xc.
    for ( ; j &gt; a; ) {

        if ( xc[--j] &lt; yc[j] ) {
            for ( i = j; i &amp;&amp; !xc[--i]; xc[i] = b );
            --xc[i];
            xc[j] += BASE;
        }

        xc[j] -= yc[j];
    }

    // Remove leading zeros and adjust exponent accordingly.
    for ( ; xc[0] == 0; xc.shift(), --ye );

    // Zero?
    if ( !xc[0] ) {

        // Following IEEE 754 (2008) 6.3,
        // n - n = +0  but  n - n = -0  when rounding towards -Infinity.
        y.s = ROUNDING_MODE == 3 ? -1 : 1;
        y.c = [ y.e = 0 ];
        return y;
    }

    // No need to check for Infinity as +x - +y != Infinity &amp;&amp; -x - -y != Infinity
    // for finite x and y.
    return normalise( y, xc, ye );
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
```

A BigNumber is immutable in the sense that it is not changed by its methods.

```javascript
0.3 - 0.1                           // 0.19999999999999998
x = new BigNumber(0.3)
x.<span class="apidocCodeKeywordSpan">minus</span>(0.1)                        // "0.2"
x                                   // "0.3"
```

The methods that return a BigNumber can be chained.

```javascript
x.dividedBy(y).plus(z).times(9).floor()
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.bignumber.js.BigNumber.prototype.mod" id="apidoc.element.bignumber.js.BigNumber.prototype.mod">
        function <span class="apidocSignatureSpan">bignumber.js.BigNumber.prototype.</span>mod
        <span class="apidocSignatureSpan">( y, b )</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">mod = function ( y, b ) {
    var q, s,
        x = this;

    id = 11;
    y = new BigNumber( y, b );

    // Return NaN if x is Infinity or NaN, or y is NaN or zero.
    if ( !x.c || !y.s || y.c &amp;&amp; !y.c[0] ) {
        return new BigNumber(NaN);

    // Return x if y is Infinity or x is zero.
    } else if ( !y.c || x.c &amp;&amp; !x.c[0] ) {
        return new BigNumber(x);
    }

    if ( MODULO_MODE == 9 ) {

        // Euclidian division: q = sign(y) * floor(x / abs(y))
        // r = x - qy    where  0 &lt;= r &lt; abs(y)
        s = y.s;
        y.s = 1;
        q = div( x, y, 0, 3 );
        y.s = s;
        q.s *= s;
    } else {
        q = div( x, y, 0, MODULO_MODE );
    }

    return x.minus( q.times(y) );
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
x.times('1.23456780123456789e+9').plus(9876.5432321).dividedBy('4444562598.111772').ceil()
```

Many method names have a shorter alias.

```javascript
x.squareRoot().dividedBy(y).toPower(3).equals(x.sqrt().div(y).pow(3))         // true
x.cmp(y.<span class="apidocCodeKeywordSpan">mod</span>(z).neg()) == 1 &amp;&amp; x.comparedTo(y.modulo(z).negated()) == 1        //
true
```

Like JavaScript's number type, there are `toExponential`, `toFixed` and `toPrecision` methods

```javascript
x = new BigNumber(255.5)
x.toExponential(5)                  // "2.55500e+2"
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.bignumber.js.BigNumber.prototype.modulo" id="apidoc.element.bignumber.js.BigNumber.prototype.modulo">
        function <span class="apidocSignatureSpan">bignumber.js.BigNumber.prototype.</span>modulo
        <span class="apidocSignatureSpan">( y, b )</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">modulo = function ( y, b ) {
    var q, s,
        x = this;

    id = 11;
    y = new BigNumber( y, b );

    // Return NaN if x is Infinity or NaN, or y is NaN or zero.
    if ( !x.c || !y.s || y.c &amp;&amp; !y.c[0] ) {
        return new BigNumber(NaN);

    // Return x if y is Infinity or x is zero.
    } else if ( !y.c || x.c &amp;&amp; !x.c[0] ) {
        return new BigNumber(x);
    }

    if ( MODULO_MODE == 9 ) {

        // Euclidian division: q = sign(y) * floor(x / abs(y))
        // r = x - qy    where  0 &lt;= r &lt; abs(y)
        s = y.s;
        y.s = 1;
        q = div( x, y, 0, 3 );
        y.s = s;
        q.s *= s;
    } else {
        q = div( x, y, 0, MODULO_MODE );
    }

    return x.minus( q.times(y) );
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
x.times('1.23456780123456789e+9').plus(9876.5432321).dividedBy('4444562598.111772').ceil()
```

Many method names have a shorter alias.

```javascript
x.squareRoot().dividedBy(y).toPower(3).equals(x.sqrt().div(y).pow(3))         // true
x.cmp(y.mod(z).neg()) == 1 &amp;&amp; x.comparedTo(y.<span class="apidocCodeKeywordSpan">modulo</span>(z).negated()) == 1        //
true
```

Like JavaScript's number type, there are `toExponential`, `toFixed` and `toPrecision` methods

```javascript
x = new BigNumber(255.5)
x.toExponential(5)                  // "2.55500e+2"
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.bignumber.js.BigNumber.prototype.mul" id="apidoc.element.bignumber.js.BigNumber.prototype.mul">
        function <span class="apidocSignatureSpan">bignumber.js.BigNumber.prototype.</span>mul
        <span class="apidocSignatureSpan">( y, b )</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">mul = function ( y, b ) {
    var c, e, i, j, k, m, xcL, xlo, xhi, ycL, ylo, yhi, zc,
        base, sqrtBase,
        x = this,
        xc = x.c,
        yc = ( id = 17, y = new BigNumber( y, b ) ).c;

    // Either NaN, Infinity or 0?
    if ( !xc || !yc || !xc[0] || !yc[0] ) {

        // Return NaN if either is NaN, or one is 0 and the other is Infinity.
        if ( !x.s || !y.s || xc &amp;&amp; !xc[0] &amp;&amp; !yc || yc &amp;&amp; !yc[0] &amp;&amp; !xc ) {
            y.c = y.e = y.s = null;
        } else {
            y.s *= x.s;

            // Return Infinity if either is Infinity.
            if ( !xc || !yc ) {
                y.c = y.e = null;

            // Return 0 if either is 0.
            } else {
                y.c = [0];
                y.e = 0;
            }
        }

        return y;
    }

    e = bitFloor( x.e / LOG_BASE ) + bitFloor( y.e / LOG_BASE );
    y.s *= x.s;
    xcL = xc.length;
    ycL = yc.length;

    // Ensure xc points to longer array and xcL to its length.
    if ( xcL &lt; ycL ) zc = xc, xc = yc, yc = zc, i = xcL, xcL = ycL, ycL = i;

    // Initialise the result array with zeros.
    for ( i = xcL + ycL, zc = []; i--; zc.push(0) );

    base = BASE;
    sqrtBase = SQRT_BASE;

    for ( i = ycL; --i &gt;= 0; ) {
        c = 0;
        ylo = yc[i] % sqrtBase;
        yhi = yc[i] / sqrtBase | 0;

        for ( k = xcL, j = i + k; j &gt; i; ) {
            xlo = xc[--k] % sqrtBase;
            xhi = xc[k] / sqrtBase | 0;
            m = yhi * xlo + xhi * ylo;
            xlo = ylo * xlo + ( ( m % sqrtBase ) * sqrtBase ) + zc[j] + c;
            c = ( xlo / base | 0 ) + ( m / sqrtBase | 0 ) + yhi * xhi;
            zc[j--] = xlo % base;
        }

        zc[j] = c;
    }

    if (c) {
        ++e;
    } else {
        zc.shift();
    }

    return normalise( y, zc, e );
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.bignumber.js.BigNumber.prototype.neg" id="apidoc.element.bignumber.js.BigNumber.prototype.neg">
        function <span class="apidocSignatureSpan">bignumber.js.BigNumber.prototype.</span>neg
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">neg = function () {
    var x = new BigNumber(this);
    x.s = -x.s || null;
    return x;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
x.times('1.23456780123456789e+9').plus(9876.5432321).dividedBy('4444562598.111772').ceil()
```

Many method names have a shorter alias.

```javascript
x.squareRoot().dividedBy(y).toPower(3).equals(x.sqrt().div(y).pow(3))         // true
x.cmp(y.mod(z).<span class="apidocCodeKeywordSpan">neg</span>()) == 1 &amp;&amp; x.comparedTo(y.modulo(z).negated()) == 1        //
true
```

Like JavaScript's number type, there are `toExponential`, `toFixed` and `toPrecision` methods

```javascript
x = new BigNumber(255.5)
x.toExponential(5)                  // "2.55500e+2"
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.bignumber.js.BigNumber.prototype.negated" id="apidoc.element.bignumber.js.BigNumber.prototype.negated">
        function <span class="apidocSignatureSpan">bignumber.js.BigNumber.prototype.</span>negated
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">negated = function () {
    var x = new BigNumber(this);
    x.s = -x.s || null;
    return x;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
x.times('1.23456780123456789e+9').plus(9876.5432321).dividedBy('4444562598.111772').ceil()
```

Many method names have a shorter alias.

```javascript
x.squareRoot().dividedBy(y).toPower(3).equals(x.sqrt().div(y).pow(3))         // true
x.cmp(y.mod(z).neg()) == 1 &amp;&amp; x.comparedTo(y.modulo(z).<span class="apidocCodeKeywordSpan">negated</span>()) == 1        //
true
```

Like JavaScript's number type, there are `toExponential`, `toFixed` and `toPrecision` methods

```javascript
x = new BigNumber(255.5)
x.toExponential(5)                  // "2.55500e+2"
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.bignumber.js.BigNumber.prototype.plus" id="apidoc.element.bignumber.js.BigNumber.prototype.plus">
        function <span class="apidocSignatureSpan">bignumber.js.BigNumber.prototype.</span>plus
        <span class="apidocSignatureSpan">( y, b )</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">plus = function ( y, b ) {
    var t,
        x = this,
        a = x.s;

    id = 12;
    y = new BigNumber( y, b );
    b = y.s;

    // Either NaN?
    if ( !a || !b ) return new BigNumber(NaN);

    // Signs differ?
     if ( a != b ) {
        y.s = -b;
        return x.minus(y);
    }

    var xe = x.e / LOG_BASE,
        ye = y.e / LOG_BASE,
        xc = x.c,
        yc = y.c;

    if ( !xe || !ye ) {

        // Return Infinity if either Infinity.
        if ( !xc || !yc ) return new BigNumber( a / 0 );

        // Either zero?
        // Return y if y is non-zero, x if x is non-zero, or zero if both are zero.
        if ( !xc[0] || !yc[0] ) return yc[0] ? y : new BigNumber( xc[0] ? x : a * 0 );
    }

    xe = bitFloor(xe);
    ye = bitFloor(ye);
    xc = xc.slice();

    // Prepend zeros to equalise exponents. Faster to use reverse then do unshifts.
    if ( a = xe - ye ) {
        if ( a &gt; 0 ) {
            ye = xe;
            t = yc;
        } else {
            a = -a;
            t = xc;
        }

        t.reverse();
        for ( ; a--; t.push(0) );
        t.reverse();
    }

    a = xc.length;
    b = yc.length;

    // Point xc to the longer array, and b to the shorter length.
    if ( a - b &lt; 0 ) t = yc, yc = xc, xc = t, b = a;

    // Only start adding at yc.length - 1 as the further digits of xc can be ignored.
    for ( a = 0; b; ) {
        a = ( xc[--b] = xc[b] + yc[b] + a ) / BASE | 0;
        xc[b] = BASE === xc[b] ? 0 : xc[b] % BASE;
    }

    if (a) {
        xc.unshift(a);
        ++ye;
    }

    // No need to check for zero, as +x + +y != 0 &amp;&amp; -x + -y != 0
    // ye = MAX_EXP + 1 possible
    return normalise( y, xc, ye );
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...


and a base from 2 to 64 inclusive can be specified.

```javascript
x = new BigNumber(1011, 2)          // "11"
y = new BigNumber('zz.9', 36)       // "1295.25"
z = x.<span class="apidocCodeKeywordSpan">plus</span>(y)                       // "1306.25"
```

A BigNumber is immutable in the sense that it is not changed by its methods.

```javascript
0.3 - 0.1                           // 0.19999999999999998
x = new BigNumber(0.3)
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.bignumber.js.BigNumber.prototype.pow" id="apidoc.element.bignumber.js.BigNumber.prototype.pow">
        function <span class="apidocSignatureSpan">bignumber.js.BigNumber.prototype.</span>pow
        <span class="apidocSignatureSpan">( n, m )</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">pow = function ( n, m ) {
    var k, y, z,
        i = mathfloor( n &lt; 0 ? -n : +n ),
        x = this;

    if ( m != null ) {
        id = 23;
        m = new BigNumber(m);
    }

    // Pass Infinity to Math.pow if exponent is out of range.
    if ( !isValidInt( n, -MAX_SAFE_INTEGER, MAX_SAFE_INTEGER, 23, 'exponent' ) &amp;&amp;
      ( !isFinite(n) || i &gt; MAX_SAFE_INTEGER &amp;&amp; ( n /= 0 ) ||
        parseFloat(n) != n &amp;&amp; !( n = NaN ) ) || n == 0 ) {
        k = Math.pow( +x, n );
        return new BigNumber( m ? k % m : k );
    }

    if (m) {
        if ( n &gt; 1 &amp;&amp; x.gt(ONE) &amp;&amp; x.isInt() &amp;&amp; m.gt(ONE) &amp;&amp; m.isInt() ) {
            x = x.mod(m);
        } else {
            z = m;

            // Nullify m so only a single mod operation is performed at the end.
            m = null;
        }
    } else if (POW_PRECISION) {

        // Truncating each coefficient array to a length of k after each multiplication
        // equates to truncating significant digits to POW_PRECISION + [28, 41],
        // i.e. there will be a minimum of 28 guard digits retained.
        // (Using + 1.5 would give [9, 21] guard digits.)
        k = mathceil( POW_PRECISION / LOG_BASE + 2 );
    }

    y = new BigNumber(ONE);

    for ( ; ; ) {
        if ( i % 2 ) {
            y = y.times(x);
            if ( !y.c ) break;
            if (k) {
                if ( y.c.length &gt; k ) y.c.length = k;
            } else if (m) {
                y = y.mod(m);
            }
        }

        i = mathfloor( i / 2 );
        if ( !i ) break;
        x = x.times(x);
        if (k) {
            if ( x.c &amp;&amp; x.c.length &gt; k ) x.c.length = k;
        } else if (m) {
            x = x.mod(m);
        }
    }

    if (m) return y;
    if ( n &lt; 0 ) y = ONE.div(y);

    return z ? y.mod(z) : k ? round( y, POW_PRECISION, ROUNDING_MODE ) : y;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
x.dividedBy(y).plus(z).times(9).floor()
x.times('1.23456780123456789e+9').plus(9876.5432321).dividedBy('4444562598.111772').ceil()
```

Many method names have a shorter alias.

```javascript
x.squareRoot().dividedBy(y).toPower(3).equals(x.sqrt().div(y).<span class="apidocCodeKeywordSpan">pow</span>(3))         // true
x.cmp(y.mod(z).neg()) == 1 &amp;&amp; x.comparedTo(y.modulo(z).negated()) == 1        // true
```

Like JavaScript's number type, there are `toExponential`, `toFixed` and `toPrecision` methods

```javascript
x = new BigNumber(255.5)
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.bignumber.js.BigNumber.prototype.precision" id="apidoc.element.bignumber.js.BigNumber.prototype.precision">
        function <span class="apidocSignatureSpan">bignumber.js.BigNumber.prototype.</span>precision
        <span class="apidocSignatureSpan">(z)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">precision = function (z) {
    var n, v,
        x = this,
        c = x.c;

    // 'precision() argument not a boolean or binary digit: {z}'
    if ( z != null &amp;&amp; z !== !!z &amp;&amp; z !== 1 &amp;&amp; z !== 0 ) {
        if (ERRORS) raise( 13, 'argument' + notBool, z );
        if ( z != !!z ) z = null;
    }

    if ( !c ) return null;
    v = c.length - 1;
    n = v * LOG_BASE + 1;

    if ( v = c[v] ) {

        // Subtract the number of trailing zeros of the last element.
        for ( ; v % 10 == 0; v /= 10, n-- );

        // Add the number of digits of the first element.
        for ( v = c[0]; v &gt;= 10; v /= 10, n++ );
    }

    if ( z &amp;&amp; x.e + 1 &gt; n ) n = x.e + 1;

    return n;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.bignumber.js.BigNumber.prototype.round" id="apidoc.element.bignumber.js.BigNumber.prototype.round">
        function <span class="apidocSignatureSpan">bignumber.js.BigNumber.prototype.</span>round
        <span class="apidocSignatureSpan">( dp, rm )</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">round = function ( dp, rm ) {
    var n = new BigNumber(this);

    if ( dp == null || isValidInt( dp, 0, MAX, 15 ) ) {
        round( n, ~~dp + this.e + 1, rm == null ||
          !isValidInt( rm, 0, 8, 15, roundingMode ) ? ROUNDING_MODE : rm | 0 );
    }

    return n;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
x = new BigNumber(2);
y = new BigNumber(3);
z = x.div(y)                        // "0.6666666667"
z.sqrt()                            // "0.8164965809"
z.pow(-3)                           // "3.3749999995"
z.toString(2)                       // "0.1010101011"
z.times(z)                          // "0.44444444448888888889"
z.times(z).<span class="apidocCodeKeywordSpan">round</span>(10)                // "0.4444444445"
```

There is a `toFraction` method with an optional *maximum denominator* argument

```javascript
y = new BigNumber(355)
pi = y.dividedBy(113)               // "3.1415929204"
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.bignumber.js.BigNumber.prototype.sd" id="apidoc.element.bignumber.js.BigNumber.prototype.sd">
        function <span class="apidocSignatureSpan">bignumber.js.BigNumber.prototype.</span>sd
        <span class="apidocSignatureSpan">(z)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">sd = function (z) {
    var n, v,
        x = this,
        c = x.c;

    // 'precision() argument not a boolean or binary digit: {z}'
    if ( z != null &amp;&amp; z !== !!z &amp;&amp; z !== 1 &amp;&amp; z !== 0 ) {
        if (ERRORS) raise( 13, 'argument' + notBool, z );
        if ( z != !!z ) z = null;
    }

    if ( !c ) return null;
    v = c.length - 1;
    n = v * LOG_BASE + 1;

    if ( v = c[v] ) {

        // Subtract the number of trailing zeros of the last element.
        for ( ; v % 10 == 0; v /= 10, n-- );

        // Add the number of digits of the first element.
        for ( v = c[0]; v &gt;= 10; v /= 10, n++ );
    }

    if ( z &amp;&amp; x.e + 1 &gt; n ) n = x.e + 1;

    return n;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.bignumber.js.BigNumber.prototype.shift" id="apidoc.element.bignumber.js.BigNumber.prototype.shift">
        function <span class="apidocSignatureSpan">bignumber.js.BigNumber.prototype.</span>shift
        <span class="apidocSignatureSpan">(k)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">shift = function (k) {
    var n = this;
    return isValidInt( k, -MAX_SAFE_INTEGER, MAX_SAFE_INTEGER, 16, 'argument' )

      // k &lt; 1e+21, or truncate(k) will produce exponential notation.
      ? n.times( '1e' + truncate(k) )
      : new BigNumber( n.c &amp;&amp; n.c[0] &amp;&amp; ( k &lt; -MAX_SAFE_INTEGER || k &gt; MAX_SAFE_INTEGER )
        ? n.s * ( k &lt; 0 ? 0 : 1 / 0 )
        : n );
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

// Zero?
if ( i &lt; 0 ) {
    c = [ e = 0 ];
} else {

    // Remove leading elements which are zero and adjust exponent accordingly.
    for ( e = -1 ; c[0] === 0; c.<span class="apidocCodeKeywordSpan">shift</span>(), e -= LOG_BASE);

    // Count the digits of the first element of c to determine leading zeros, and...
    for ( i = 1, v = c[0]; v &gt;= 10; v /= 10, i++);

    // adjust the exponent accordingly.
    if ( i &lt; LOG_BASE ) e -= LOG_BASE - i;
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.bignumber.js.BigNumber.prototype.sqrt" id="apidoc.element.bignumber.js.BigNumber.prototype.sqrt">
        function <span class="apidocSignatureSpan">bignumber.js.BigNumber.prototype.</span>sqrt
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">sqrt = function () {
    var m, n, r, rep, t,
        x = this,
        c = x.c,
        s = x.s,
        e = x.e,
        dp = DECIMAL_PLACES + 4,
        half = new BigNumber('0.5');

    // Negative/NaN/Infinity/zero?
    if ( s !== 1 || !c || !c[0] ) {
        return new BigNumber( !s || s &lt; 0 &amp;&amp; ( !c || c[0] ) ? NaN : c ? x : 1 / 0 );
    }

    // Initial estimate.
    s = Math.sqrt( +x );

    // Math.sqrt underflow/overflow?
    // Pass x to Math.sqrt as integer, then adjust the exponent of the result.
    if ( s == 0 || s == 1 / 0 ) {
        n = coeffToString(c);
        if ( ( n.length + e ) % 2 == 0 ) n += '0';
        s = Math.sqrt(n);
        e = bitFloor( ( e + 1 ) / 2 ) - ( e &lt; 0 || e % 2 );

        if ( s == 1 / 0 ) {
            n = '1e' + e;
        } else {
            n = s.toExponential();
            n = n.slice( 0, n.indexOf('e') + 1 ) + e;
        }

        r = new BigNumber(n);
    } else {
        r = new BigNumber( s + '' );
    }

    // Check for zero.
    // r could be zero if MIN_EXP is changed after the this value was created.
    // This would cause a division by zero (x/t) and hence Infinity below, which would cause
    // coeffToString to throw.
    if ( r.c[0] ) {
        e = r.e;
        s = e + dp;
        if ( s &lt; 3 ) s = 0;

        // Newton-Raphson iteration.
        for ( ; ; ) {
            t = r;
            r = half.times( t.plus( div( x, t, dp, 1 ) ) );

            if ( coeffToString( t.c   ).slice( 0, s ) === ( n =
                 coeffToString( r.c ) ).slice( 0, s ) ) {

                // The exponent of r may here be one less than the final result exponent,
                // e.g 0.0009999 (e-4) --&gt; 0.001 (e-3), so adjust s so the rounding digits
                // are indexed correctly.
                if ( r.e &lt; e ) --s;
                n = n.slice( s - 3, s + 1 );

                // The 4th rounding digit may be in error by -1 so if the 4 rounding digits
                // are 9999 or 4999 (i.e. approaching a rounding boundary) continue the
                // iteration.
                if ( n == '9999' || !rep &amp;&amp; n == '4999' ) {

                    // On the first iteration only, check to see if rounding up gives the
                    // exact result as the nines may infinitely repeat.
                    if ( !rep ) {
                        round( t, t.e + DECIMAL_PLACES + 2, 0 );

                        if ( t.times(t).eq(x) ) {
                            r = t;
                            break;
                        }
                    }

                    dp += 4;
                    s += 4;
                    rep = 1;
                } else {

                    // If rounding digits are null, 0{0,4} or 50{0,3}, check for exact
                    // result. If not, then there are further digits and m will be truthy.
                    if ( !+n || !+n.slice(1) &amp;&amp; n.charAt(0) == '5' ) {

                        // Truncate to the first rounding digit.
                        round( r, r.e + DECIMAL_PLACES + 2, 1 );
                        m = !r.times(r).eq(x);
                    }

                    break;
                }
            }
        }
    }

    return round( r, r.e + DECIMAL_PLACES + 1, ROUNDING_MODE, m );
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
x.dividedBy(y).plus(z).times(9).floor()
x.times('1.23456780123456789e+9').plus(9876.5432321).dividedBy('4444562598.111772').ceil()
```

Many method names have a shorter alias.

```javascript
x.squareRoot().dividedBy(y).toPower(3).equals(x.<span class="apidocCodeKeywordSpan">sqrt</span>().div(y).pow(3))         // true
x.cmp(y.mod(z).neg()) == 1 &amp;&amp; x.comparedTo(y.modulo(z).negated()) == 1        // true
```

Like JavaScript's number type, there are `toExponential`, `toFixed` and `toPrecision` methods

```javascript
x = new BigNumber(255.5)
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.bignumber.js.BigNumber.prototype.squareRoot" id="apidoc.element.bignumber.js.BigNumber.prototype.squareRoot">
        function <span class="apidocSignatureSpan">bignumber.js.BigNumber.prototype.</span>squareRoot
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">squareRoot = function () {
    var m, n, r, rep, t,
        x = this,
        c = x.c,
        s = x.s,
        e = x.e,
        dp = DECIMAL_PLACES + 4,
        half = new BigNumber('0.5');

    // Negative/NaN/Infinity/zero?
    if ( s !== 1 || !c || !c[0] ) {
        return new BigNumber( !s || s &lt; 0 &amp;&amp; ( !c || c[0] ) ? NaN : c ? x : 1 / 0 );
    }

    // Initial estimate.
    s = Math.sqrt( +x );

    // Math.sqrt underflow/overflow?
    // Pass x to Math.sqrt as integer, then adjust the exponent of the result.
    if ( s == 0 || s == 1 / 0 ) {
        n = coeffToString(c);
        if ( ( n.length + e ) % 2 == 0 ) n += '0';
        s = Math.sqrt(n);
        e = bitFloor( ( e + 1 ) / 2 ) - ( e &lt; 0 || e % 2 );

        if ( s == 1 / 0 ) {
            n = '1e' + e;
        } else {
            n = s.toExponential();
            n = n.slice( 0, n.indexOf('e') + 1 ) + e;
        }

        r = new BigNumber(n);
    } else {
        r = new BigNumber( s + '' );
    }

    // Check for zero.
    // r could be zero if MIN_EXP is changed after the this value was created.
    // This would cause a division by zero (x/t) and hence Infinity below, which would cause
    // coeffToString to throw.
    if ( r.c[0] ) {
        e = r.e;
        s = e + dp;
        if ( s &lt; 3 ) s = 0;

        // Newton-Raphson iteration.
        for ( ; ; ) {
            t = r;
            r = half.times( t.plus( div( x, t, dp, 1 ) ) );

            if ( coeffToString( t.c   ).slice( 0, s ) === ( n =
                 coeffToString( r.c ) ).slice( 0, s ) ) {

                // The exponent of r may here be one less than the final result exponent,
                // e.g 0.0009999 (e-4) --&gt; 0.001 (e-3), so adjust s so the rounding digits
                // are indexed correctly.
                if ( r.e &lt; e ) --s;
                n = n.slice( s - 3, s + 1 );

                // The 4th rounding digit may be in error by -1 so if the 4 rounding digits
                // are 9999 or 4999 (i.e. approaching a rounding boundary) continue the
                // iteration.
                if ( n == '9999' || !rep &amp;&amp; n == '4999' ) {

                    // On the first iteration only, check to see if rounding up gives the
                    // exact result as the nines may infinitely repeat.
                    if ( !rep ) {
                        round( t, t.e + DECIMAL_PLACES + 2, 0 );

                        if ( t.times(t).eq(x) ) {
                            r = t;
                            break;
                        }
                    }

                    dp += 4;
                    s += 4;
                    rep = 1;
                } else {

                    // If rounding digits are null, 0{0,4} or 50{0,3}, check for exact
                    // result. If not, then there are further digits and m will be truthy.
                    if ( !+n || !+n.slice(1) &amp;&amp; n.charAt(0) == '5' ) {

                        // Truncate to the first rounding digit.
                        round( r, r.e + DECIMAL_PLACES + 2, 1 );
                        m = !r.times(r).eq(x);
                    }

                    break;
                }
            }
        }
    }

    return round( r, r.e + DECIMAL_PLACES + 1, ROUNDING_MODE, m );
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
x.dividedBy(y).plus(z).times(9).floor()
x.times('1.23456780123456789e+9').plus(9876.5432321).dividedBy('4444562598.111772').ceil()
```

Many method names have a shorter alias.

```javascript
x.<span class="apidocCodeKeywordSpan">squareRoot</span>().dividedBy(y).toPower(3).equals(x.sqrt().div(y).pow(3))         // true
x.cmp(y.mod(z).neg()) == 1 &amp;&amp; x.comparedTo(y.modulo(z).negated()) == 1        // true
```

Like JavaScript's number type, there are `toExponential`, `toFixed` and `toPrecision` methods

```javascript
x = new BigNumber(255.5)
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.bignumber.js.BigNumber.prototype.sub" id="apidoc.element.bignumber.js.BigNumber.prototype.sub">
        function <span class="apidocSignatureSpan">bignumber.js.BigNumber.prototype.</span>sub
        <span class="apidocSignatureSpan">( y, b )</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">sub = function ( y, b ) {
    var i, j, t, xLTy,
        x = this,
        a = x.s;

    id = 10;
    y = new BigNumber( y, b );
    b = y.s;

    // Either NaN?
    if ( !a || !b ) return new BigNumber(NaN);

    // Signs differ?
    if ( a != b ) {
        y.s = -b;
        return x.plus(y);
    }

    var xe = x.e / LOG_BASE,
        ye = y.e / LOG_BASE,
        xc = x.c,
        yc = y.c;

    if ( !xe || !ye ) {

        // Either Infinity?
        if ( !xc || !yc ) return xc ? ( y.s = -b, y ) : new BigNumber( yc ? x : NaN );

        // Either zero?
        if ( !xc[0] || !yc[0] ) {

            // Return y if y is non-zero, x if x is non-zero, or zero if both are zero.
            return yc[0] ? ( y.s = -b, y ) : new BigNumber( xc[0] ? x :

              // IEEE 754 (2008) 6.3: n - n = -0 when rounding to -Infinity
              ROUNDING_MODE == 3 ? -0 : 0 );
        }
    }

    xe = bitFloor(xe);
    ye = bitFloor(ye);
    xc = xc.slice();

    // Determine which is the bigger number.
    if ( a = xe - ye ) {

        if ( xLTy = a &lt; 0 ) {
            a = -a;
            t = xc;
        } else {
            ye = xe;
            t = yc;
        }

        t.reverse();

        // Prepend zeros to equalise exponents.
        for ( b = a; b--; t.push(0) );
        t.reverse();
    } else {

        // Exponents equal. Check digit by digit.
        j = ( xLTy = ( a = xc.length ) &lt; ( b = yc.length ) ) ? a : b;

        for ( a = b = 0; b &lt; j; b++ ) {

            if ( xc[b] != yc[b] ) {
                xLTy = xc[b] &lt; yc[b];
                break;
            }
        }
    }

    // x &lt; y? Point xc to the array of the bigger number.
    if (xLTy) t = xc, xc = yc, yc = t, y.s = -y.s;

    b = ( j = yc.length ) - ( i = xc.length );

    // Append zeros to xc if shorter.
    // No need to add zeros to yc if shorter as subtract only needs to start at yc.length.
    if ( b &gt; 0 ) for ( ; b--; xc[i++] = 0 );
    b = BASE - 1;

    // Subtract yc from xc.
    for ( ; j &gt; a; ) {

        if ( xc[--j] &lt; yc[j] ) {
            for ( i = j; i &amp;&amp; !xc[--i]; xc[i] = b );
            --xc[i];
            xc[j] += BASE;
        }

        xc[j] -= yc[j];
    }

    // Remove leading zeros and adjust exponent accordingly.
    for ( ; xc[0] == 0; xc.shift(), --ye );

    // Zero?
    if ( !xc[0] ) {

        // Following IEEE 754 (2008) 6.3,
        // n - n = +0  but  n - n = -0  when rounding towards -Infinity.
        y.s = ROUNDING_MODE == 3 ? -1 : 1;
        y.c = [ y.e = 0 ];
        return y;
    }

    // No need to check for Infinity as +x - +y != Infinity &amp;&amp; -x - -y != Infinity
    // for finite x and y.
    return normalise( y, xc, ye );
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.bignumber.js.BigNumber.prototype.times" id="apidoc.element.bignumber.js.BigNumber.prototype.times">
        function <span class="apidocSignatureSpan">bignumber.js.BigNumber.prototype.</span>times
        <span class="apidocSignatureSpan">( y, b )</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">times = function ( y, b ) {
    var c, e, i, j, k, m, xcL, xlo, xhi, ycL, ylo, yhi, zc,
        base, sqrtBase,
        x = this,
        xc = x.c,
        yc = ( id = 17, y = new BigNumber( y, b ) ).c;

    // Either NaN, Infinity or 0?
    if ( !xc || !yc || !xc[0] || !yc[0] ) {

        // Return NaN if either is NaN, or one is 0 and the other is Infinity.
        if ( !x.s || !y.s || xc &amp;&amp; !xc[0] &amp;&amp; !yc || yc &amp;&amp; !yc[0] &amp;&amp; !xc ) {
            y.c = y.e = y.s = null;
        } else {
            y.s *= x.s;

            // Return Infinity if either is Infinity.
            if ( !xc || !yc ) {
                y.c = y.e = null;

            // Return 0 if either is 0.
            } else {
                y.c = [0];
                y.e = 0;
            }
        }

        return y;
    }

    e = bitFloor( x.e / LOG_BASE ) + bitFloor( y.e / LOG_BASE );
    y.s *= x.s;
    xcL = xc.length;
    ycL = yc.length;

    // Ensure xc points to longer array and xcL to its length.
    if ( xcL &lt; ycL ) zc = xc, xc = yc, yc = zc, i = xcL, xcL = ycL, ycL = i;

    // Initialise the result array with zeros.
    for ( i = xcL + ycL, zc = []; i--; zc.push(0) );

    base = BASE;
    sqrtBase = SQRT_BASE;

    for ( i = ycL; --i &gt;= 0; ) {
        c = 0;
        ylo = yc[i] % sqrtBase;
        yhi = yc[i] / sqrtBase | 0;

        for ( k = xcL, j = i + k; j &gt; i; ) {
            xlo = xc[--k] % sqrtBase;
            xhi = xc[k] / sqrtBase | 0;
            m = yhi * xlo + xhi * ylo;
            xlo = ylo * xlo + ( ( m % sqrtBase ) * sqrtBase ) + zc[j] + c;
            c = ( xlo / base | 0 ) + ( m / sqrtBase | 0 ) + yhi * xhi;
            zc[j--] = xlo % base;
        }

        zc[j] = c;
    }

    if (c) {
        ++e;
    } else {
        zc.shift();
    }

    return normalise( y, zc, e );
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
x.minus(0.1)                        // "0.2"
x                                   // "0.3"
```

The methods that return a BigNumber can be chained.

```javascript
x.dividedBy(y).plus(z).<span class="apidocCodeKeywordSpan">times</span>(9).floor()
x.times('1.23456780123456789e+9').plus(9876.5432321).dividedBy('4444562598.111772').ceil()
```

Many method names have a shorter alias.

```javascript
x.squareRoot().dividedBy(y).toPower(3).equals(x.sqrt().div(y).pow(3))         // true
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.bignumber.js.BigNumber.prototype.toDigits" id="apidoc.element.bignumber.js.BigNumber.prototype.toDigits">
        function <span class="apidocSignatureSpan">bignumber.js.BigNumber.prototype.</span>toDigits
        <span class="apidocSignatureSpan">( sd, rm )</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">toDigits = function ( sd, rm ) {
    var n = new BigNumber(this);
    sd = sd == null || !isValidInt( sd, 1, MAX, 18, 'precision' ) ? null : sd | 0;
    rm = rm == null || !isValidInt( rm, 0, 8, 18, roundingMode ) ? ROUNDING_MODE : rm | 0;
    return sd ? round( n, sd, rm ) : n;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.bignumber.js.BigNumber.prototype.toExponential" id="apidoc.element.bignumber.js.BigNumber.prototype.toExponential">
        function <span class="apidocSignatureSpan">bignumber.js.BigNumber.prototype.</span>toExponential
        <span class="apidocSignatureSpan">( dp, rm )</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">toExponential = function ( dp, rm ) {
    return format( this,
      dp != null &amp;&amp; isValidInt( dp, 0, MAX, 19 ) ? ~~dp + 1 : null, rm, 19 );
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
x.cmp(y.mod(z).neg()) == 1 &amp;&amp; x.comparedTo(y.modulo(z).negated()) == 1        // true
```

Like JavaScript's number type, there are `toExponential`, `toFixed` and `toPrecision` methods

```javascript
x = new BigNumber(255.5)
x.<span class="apidocCodeKeywordSpan">toExponential</span>(5)                  // "2.55500e+2"
x.toFixed(5)                        // "255.50000"
x.toPrecision(5)                    // "255.50"
x.toNumber()                        // 255.5
```

and a base can be specified for `toString`.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.bignumber.js.BigNumber.prototype.toFixed" id="apidoc.element.bignumber.js.BigNumber.prototype.toFixed">
        function <span class="apidocSignatureSpan">bignumber.js.BigNumber.prototype.</span>toFixed
        <span class="apidocSignatureSpan">( dp, rm )</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">toFixed = function ( dp, rm ) {
    return format( this, dp != null &amp;&amp; isValidInt( dp, 0, MAX, 20 )
      ? ~~dp + this.e + 1 : null, rm, 20 );
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
```

Like JavaScript's number type, there are `toExponential`, `toFixed` and `toPrecision` methods

```javascript
x = new BigNumber(255.5)
x.toExponential(5)                  // "2.55500e+2"
x.<span class="apidocCodeKeywordSpan">toFixed</span>(5)                        // "255.50000"
x.toPrecision(5)                    // "255.50"
x.toNumber()                        // 255.5
```

and a base can be specified for `toString`.

```javascript
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.bignumber.js.BigNumber.prototype.toFormat" id="apidoc.element.bignumber.js.BigNumber.prototype.toFormat">
        function <span class="apidocSignatureSpan">bignumber.js.BigNumber.prototype.</span>toFormat
        <span class="apidocSignatureSpan">( dp, rm )</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">toFormat = function ( dp, rm ) {
    var str = format( this, dp != null &amp;&amp; isValidInt( dp, 0, MAX, 21 )
      ? ~~dp + this.e + 1 : null, rm, 21 );

    if ( this.c ) {
        var i,
            arr = str.split('.'),
            g1 = +FORMAT.groupSize,
            g2 = +FORMAT.secondaryGroupSize,
            groupSeparator = FORMAT.groupSeparator,
            intPart = arr[0],
            fractionPart = arr[1],
            isNeg = this.s &lt; 0,
            intDigits = isNeg ? intPart.slice(1) : intPart,
            len = intDigits.length;

        if (g2) i = g1, g1 = g2, g2 = i, len -= i;

        if ( g1 &gt; 0 &amp;&amp; len &gt; 0 ) {
            i = len % g1 || g1;
            intPart = intDigits.substr( 0, i );

            for ( ; i &lt; len; i += g1 ) {
                intPart += groupSeparator + intDigits.substr( i, g1 );
            }

            if ( g2 &gt; 0 ) intPart += groupSeparator + intDigits.slice(i);
            if (isNeg) intPart = '-' + intPart;
        }

        str = fractionPart
          ? intPart + FORMAT.decimalSeparator + ( ( g2 = +FORMAT.fractionGroupSize )
            ? fractionPart.replace( new RegExp( '\\d{' + g2 + '}\\B', 'g' ),
              '$&amp;' + FORMAT.fractionGroupSeparator )
            : fractionPart )
          : intPart;
    }

    return str;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 x.toString(16)                     // "ff.8"
 ```

There is also a `toFormat` method which may be useful for internationalisation

```javascript
y = new BigNumber('1234567.898765')
y.<span class="apidocCodeKeywordSpan">toFormat</span>(2)                       // "1,234,567.90"
```

The maximum number of decimal places of the result of an operation involving division (i.e. a division, square root, base conversion
 or negative power operation) is set using the `config` method of the `BigNumber` constructor.

The other arithmetic operations always give the exact result.

```javascript
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.bignumber.js.BigNumber.prototype.toFraction" id="apidoc.element.bignumber.js.BigNumber.prototype.toFraction">
        function <span class="apidocSignatureSpan">bignumber.js.BigNumber.prototype.</span>toFraction
        <span class="apidocSignatureSpan">(md)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">toFraction = function (md) {
    var arr, d0, d2, e, exp, n, n0, q, s,
        k = ERRORS,
        x = this,
        xc = x.c,
        d = new BigNumber(ONE),
        n1 = d0 = new BigNumber(ONE),
        d1 = n0 = new BigNumber(ONE);

    if ( md != null ) {
        ERRORS = false;
        n = new BigNumber(md);
        ERRORS = k;

        if ( !( k = n.isInt() ) || n.lt(ONE) ) {

            if (ERRORS) {
                raise( 22,
                  'max denominator ' + ( k ? 'out of range' : 'not an integer' ), md );
            }

            // ERRORS is false:
            // If md is a finite non-integer &gt;= 1, round it to an integer and use it.
            md = !k &amp;&amp; n.c &amp;&amp; round( n, n.e + 1, 1 ).gte(ONE) ? n : null;
        }
    }

    if ( !xc ) return x.toString();
    s = coeffToString(xc);

    // Determine initial denominator.
    // d is a power of 10 and the minimum max denominator that specifies the value exactly.
    e = d.e = s.length - x.e - 1;
    d.c[0] = POWS_TEN[ ( exp = e % LOG_BASE ) &lt; 0 ? LOG_BASE + exp : exp ];
    md = !md || n.cmp(d) &gt; 0 ? ( e &gt; 0 ? d : n1 ) : n;

    exp = MAX_EXP;
    MAX_EXP = 1 / 0;
    n = new BigNumber(s);

    // n0 = d1 = 0
    n0.c[0] = 0;

    for ( ; ; )  {
        q = div( n, d, 0, 1 );
        d2 = d0.plus( q.times(d1) );
        if ( d2.cmp(md) == 1 ) break;
        d0 = d1;
        d1 = d2;
        n1 = n0.plus( q.times( d2 = n1 ) );
        n0 = d2;
        d = n.minus( q.times( d2 = d ) );
        n = d2;
    }

    d2 = div( md.minus(d0), d1, 0, 1 );
    n0 = n0.plus( d2.times(n1) );
    d0 = d0.plus( d2.times(d1) );
    n0.s = n1.s = x.s;
    e *= 2;

    // Determine which fraction is closer to x, n0/d0 or n1/d1
    arr = div( n1, d1, e, ROUNDING_MODE ).minus(x).abs().cmp(
          div( n0, d0, e, ROUNDING_MODE ).minus(x).abs() ) &lt; 1
            ? [ n1.toString(), d1.toString() ]
            : [ n0.toString(), d0.toString() ];

    MAX_EXP = exp;
    return arr;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
```

There is a `toFraction` method with an optional *maximum denominator* argument

```javascript
y = new BigNumber(355)
pi = y.dividedBy(113)               // "3.1415929204"
pi.<span class="apidocCodeKeywordSpan">toFraction</span>()                     // [ "7853982301", "2500000000"
; ]
pi.toFraction(1000)                 // [ "355", "113" ]
```

and `isNaN` and `isFinite` methods, as `NaN` and `Infinity` are valid `BigNumber` values.

```javascript
x = new BigNumber(NaN)                                           // "NaN"
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.bignumber.js.BigNumber.prototype.toJSON" id="apidoc.element.bignumber.js.BigNumber.prototype.toJSON">
        function <span class="apidocSignatureSpan">bignumber.js.BigNumber.prototype.</span>toJSON
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">toJSON = function () {
    var str,
        n = this,
        e = n.e;

    if ( e === null ) return n.toString();

    str = coeffToString( n.c );

    str = e &lt;= TO_EXP_NEG || e &gt;= TO_EXP_POS
        ? toExponential( str, e )
        : toFixedPoint( str, e );

    return n.s &lt; 0 ? '-' + str : str;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.bignumber.js.BigNumber.prototype.toNumber" id="apidoc.element.bignumber.js.BigNumber.prototype.toNumber">
        function <span class="apidocSignatureSpan">bignumber.js.BigNumber.prototype.</span>toNumber
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">toNumber = function () {
    return +this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
Like JavaScript's number type, there are `toExponential`, `toFixed` and `toPrecision` methods

```javascript
x = new BigNumber(255.5)
x.toExponential(5)                  // "2.55500e+2"
x.toFixed(5)                        // "255.50000"
x.toPrecision(5)                    // "255.50"
x.<span class="apidocCodeKeywordSpan">toNumber</span>()                        // 255.5
```

and a base can be specified for `toString`.

```javascript
x.toString(16)                     // "ff.8"
```
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.bignumber.js.BigNumber.prototype.toPower" id="apidoc.element.bignumber.js.BigNumber.prototype.toPower">
        function <span class="apidocSignatureSpan">bignumber.js.BigNumber.prototype.</span>toPower
        <span class="apidocSignatureSpan">( n, m )</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">toPower = function ( n, m ) {
    var k, y, z,
        i = mathfloor( n &lt; 0 ? -n : +n ),
        x = this;

    if ( m != null ) {
        id = 23;
        m = new BigNumber(m);
    }

    // Pass Infinity to Math.pow if exponent is out of range.
    if ( !isValidInt( n, -MAX_SAFE_INTEGER, MAX_SAFE_INTEGER, 23, 'exponent' ) &amp;&amp;
      ( !isFinite(n) || i &gt; MAX_SAFE_INTEGER &amp;&amp; ( n /= 0 ) ||
        parseFloat(n) != n &amp;&amp; !( n = NaN ) ) || n == 0 ) {
        k = Math.pow( +x, n );
        return new BigNumber( m ? k % m : k );
    }

    if (m) {
        if ( n &gt; 1 &amp;&amp; x.gt(ONE) &amp;&amp; x.isInt() &amp;&amp; m.gt(ONE) &amp;&amp; m.isInt() ) {
            x = x.mod(m);
        } else {
            z = m;

            // Nullify m so only a single mod operation is performed at the end.
            m = null;
        }
    } else if (POW_PRECISION) {

        // Truncating each coefficient array to a length of k after each multiplication
        // equates to truncating significant digits to POW_PRECISION + [28, 41],
        // i.e. there will be a minimum of 28 guard digits retained.
        // (Using + 1.5 would give [9, 21] guard digits.)
        k = mathceil( POW_PRECISION / LOG_BASE + 2 );
    }

    y = new BigNumber(ONE);

    for ( ; ; ) {
        if ( i % 2 ) {
            y = y.times(x);
            if ( !y.c ) break;
            if (k) {
                if ( y.c.length &gt; k ) y.c.length = k;
            } else if (m) {
                y = y.mod(m);
            }
        }

        i = mathfloor( i / 2 );
        if ( !i ) break;
        x = x.times(x);
        if (k) {
            if ( x.c &amp;&amp; x.c.length &gt; k ) x.c.length = k;
        } else if (m) {
            x = x.mod(m);
        }
    }

    if (m) return y;
    if ( n &lt; 0 ) y = ONE.div(y);

    return z ? y.mod(z) : k ? round( y, POW_PRECISION, ROUNDING_MODE ) : y;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
x.dividedBy(y).plus(z).times(9).floor()
x.times('1.23456780123456789e+9').plus(9876.5432321).dividedBy('4444562598.111772').ceil()
```

Many method names have a shorter alias.

```javascript
x.squareRoot().dividedBy(y).<span class="apidocCodeKeywordSpan">toPower</span>(3).equals(x.sqrt().div(y).pow(3))         // true
x.cmp(y.mod(z).neg()) == 1 &amp;&amp; x.comparedTo(y.modulo(z).negated()) == 1        // true
```

Like JavaScript's number type, there are `toExponential`, `toFixed` and `toPrecision` methods

```javascript
x = new BigNumber(255.5)
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.bignumber.js.BigNumber.prototype.toPrecision" id="apidoc.element.bignumber.js.BigNumber.prototype.toPrecision">
        function <span class="apidocSignatureSpan">bignumber.js.BigNumber.prototype.</span>toPrecision
        <span class="apidocSignatureSpan">( sd, rm )</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">toPrecision = function ( sd, rm ) {
    return format( this, sd != null &amp;&amp; isValidInt( sd, 1, MAX, 24, 'precision' )
      ? sd | 0 : null, rm, 24 );
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

Like JavaScript's number type, there are `toExponential`, `toFixed` and `toPrecision` methods

```javascript
x = new BigNumber(255.5)
x.toExponential(5)                  // "2.55500e+2"
x.toFixed(5)                        // "255.50000"
x.<span class="apidocCodeKeywordSpan">toPrecision</span>(5)                    // "255.50"
x.toNumber()                        // 255.5
```

and a base can be specified for `toString`.

```javascript
x.toString(16)                     // "ff.8"
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.bignumber.js.BigNumber.prototype.toString" id="apidoc.element.bignumber.js.BigNumber.prototype.toString">
        function <span class="apidocSignatureSpan">bignumber.js.BigNumber.prototype.</span>toString
        <span class="apidocSignatureSpan">(b)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">toString = function (b) {
    var str,
        n = this,
        s = n.s,
        e = n.e;

    // Infinity or NaN?
    if ( e === null ) {

        if (s) {
            str = 'Infinity';
            if ( s &lt; 0 ) str = '-' + str;
        } else {
            str = 'NaN';
        }
    } else {
        str = coeffToString( n.c );

        if ( b == null || !isValidInt( b, 2, 64, 25, 'base' ) ) {
            str = e &lt;= TO_EXP_NEG || e &gt;= TO_EXP_POS
              ? toExponential( str, e )
              : toFixedPoint( str, e );
        } else {
            str = convertBase( toFixedPoint( str, e ), b | 0, 10, s );
        }

        if ( s &lt; 0 &amp;&amp; n.c[0] ) str = '-' + str;
    }

    return str;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
x.toPrecision(5)                    // "255.50"
x.toNumber()                        // 255.5
```

 and a base can be specified for `toString`.

 ```javascript
 x.<span class="apidocCodeKeywordSpan">toString</span>(16)                     // "ff.8"
 ```

There is also a `toFormat` method which may be useful for internationalisation

```javascript
y = new BigNumber('1234567.898765')
y.toFormat(2)                       // "1,234,567.90"
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.bignumber.js.BigNumber.prototype.trunc" id="apidoc.element.bignumber.js.BigNumber.prototype.trunc">
        function <span class="apidocSignatureSpan">bignumber.js.BigNumber.prototype.</span>trunc
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">trunc = function () {
    return round( new BigNumber(this), this.e + 1, 1 );
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.bignumber.js.BigNumber.prototype.truncated" id="apidoc.element.bignumber.js.BigNumber.prototype.truncated">
        function <span class="apidocSignatureSpan">bignumber.js.BigNumber.prototype.</span>truncated
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">truncated = function () {
    return round( new BigNumber(this), this.e + 1, 1 );
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.bignumber.js.BigNumber.prototype.valueOf" id="apidoc.element.bignumber.js.BigNumber.prototype.valueOf">
        function <span class="apidocSignatureSpan">bignumber.js.BigNumber.prototype.</span>valueOf
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">valueOf = function () {
    var str,
        n = this,
        e = n.e;

    if ( e === null ) return n.toString();

    str = coeffToString( n.c );

    str = e &lt;= TO_EXP_NEG || e &gt;= TO_EXP_POS
        ? toExponential( str, e )
        : toFixedPoint( str, e );

    return n.s &lt; 0 ? '-' + str : str;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocFooterDiv">
    [ this document was created with
    <a href="https://github.com/kaizhu256/node-utility2" target="_blank">utility2</a>
    ]
</div>
</div>
</body></html>